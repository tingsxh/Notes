[TOC]

## MySql 相关阅读笔记

### 实现细节

* 如何写入数据？
* 如何主从复制？
* 如何读写分离？
* 如何分库分表？
* https://www.cnblogs.com/aspirant/p/9177978.html

### 日志文件

* 二进制文件（binaryLog）：
* 
* 记录了所有对该数据库执行更改操作具体过程。主要用于数据恢复，主备之间的复制，以及操作审计之类的。二级制日志是在事物提交之前进行提交，只写入磁盘一次，不论这时事物大小。

* 记录的是关于一个事务的具体操作内容，属于是逻辑日志。

* 重做日志文件：

 只记录与该存储引擎相关的事物日志。且重做日志记录的是每个页的更改情况，比如在某个偏移量插入了什么数据。重做日志是在事物执行的过程中被不断的被写入。
 
 * Undo 日志

  undo 日志记录的是逻辑日志，主要用于回滚和多版本并发控制

* Redo 日志

  Redo 日志记录的是物理日志，主要用于数据库崩溃时的复原
### 事务

* 事务被认为是不可分割的最下隔离单元，但提到事务就必须会谈到其四大特性: 原子性，隔离性，一致性，持久性。
* 事务的持久性保障主要是依赖操作日志，任何修改数据的操作都会被记录操作日志，持久化至磁盘当中。

#### 隔离级别

* 未提交读、提交读、可重复读(MySql的默认隔离级别)、序列化串行读。

#### 并发下存在的问题

* 脏读：读取了其他线程还未提交的数据，比如A 修改了数据，B读取了其修改后的数据，但是A 又回滚了，导致B 读取到的其实是脏数据。
* 幻读：A线程 在第一次读取 和第二次读取直接，读取了B 线程新插入的数据，造成两次结果集合不一致的问题。
* 不可重复读：与幻读类似，但主要是针对另外一个事务对数据进行了修改。

#### 什么是幻读？

* 是指在同一事务条件下，连续执行两次同样的SQL语句可能导致不同的结果，第二次SQL语句可能会返回之前不存在的行

* 幻读是在`可重复读`的事务隔离级别下会出现的一种问题，简单来说，`可重复读`保证了当前事务不会读取到其他事务已提交的 `UPDATE` 操作。但同时，也会导致当  前事务无法感知到来自其他事务中的 `INSERT` 或 `DELETE` 操作，这就是`幻读`。

#### 回滚日志

#### 存储过程

* 预先定义好的一组sql 语句集合，预先编译好，执行速度快省去了客户端的连接时间。

#### 视图

* 视图的作用主要预设值一个虚拟表，虚拟表的数据与真实表同步。比如有一个复杂的查询语句，这样可以设置一个视图，然后每次查询只需要查询该虚拟表即可。

#### 分区表

* mysql 支持如下几种分区range、list、hash、key ，无论创建哪种类型的分区，如果表中存在唯一索引列时，分区列必须是唯一索引列的一部分。
* **RANGE 分区**

```sql
-- 创建表，设置分区，id<10 的存储在p1 分区
create tabel test(id int primary key) 
partition by RANGE(id) partition p1 values LESS THAN (20)
```

* **LIST 分区**

```mysql
create tabel test(
    id int primary key
) engine=innodb
partition by LIST(id) partition p1 values IN (3,20)
```

* 在分区表下面还可以有子分区
* **HASH 分区** 对于是否能将数据平均分散到各个分区，这取决于分区值是否是连续分布的。

```mysql
create table user(
a int,
b datetime
) engine=innodb
partition by HASE (year(b))
partitions 4
```

* **KEY 分区** 和HASH 分区一致，只不过分区用的方法是数据库自带的，PASWORD()

* 除此之外还有 **COLUMNS 分区**， 对应其他几种分区都得保证分区列时整形，或者计算之后是整形，单COLUMNS 分区不需要考虑。

#### 触发器

* 针对 insert、update、delete 的事件监听，来触发运行一段sql 集合。

### 索引

#### InnoDB 索引结构

* **值得注意的是 B+ 数索引并不能直接找到指定的数据，只能找到数据所在的页，然后把该页加载到内存中，在内存中进行查找**

##### B树

* B 树： B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构 .
* B 树同样保持着左子树小于当前节点，右子树大于当前节点的排列顺序。
* B 树的每个节点都保存着 `当前关键字数据的指针，叶子节点的指针`，并且所有叶子节点都在同一层。
* B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了 ,这样来说对于一颗树的层级就减少了，这样查找速度会更快

##### B+ 树

* B+ 树： B+ 树是在B树的基础上改进的一种数据结构。
* B+跟B树不同B+树的 **非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加，层数就会更加少
* B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
* B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
* 非叶子节点的子节点数=关键字数（来源百度百科）虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）
* 在进行全表扫描的时候，只需要扫描所有叶子节点即可，速度会更快。

##### 聚集索引、辅助索引

* 聚集索引与辅助索引都是B+树构成的高度平衡树，叶子节点存放着所有的数据，聚集索引与辅助索引不同点在于**叶子节点存放的是一整行的信息**。
* 聚集索引是按照数据库主键来构造的一棵B+数，按顺序存放。**聚集索引叶子节点存放的就是一行的完整数据，可以直接找到指定数据行** 
* **辅助索引，每个叶子节点只包含了键值，和指向聚集索引的键**， 一般的非主键索引的查找顺序是先通过辅助索引查找到叶子节点，该叶子节点存有指向聚集索引数据的键值。

##### 哈希索引( 对应Innodb 而言 哈希索引是自适应的，不能人工干预)

* 使用索引列全值作hash值来索引数据，只存在精确匹配。如果出现不同数据行hash值一致的话，则会以链表的方式存放多个记录指针。
* 哈希索引只存储哈希值和行的指针而不存储字段值
* 哈希索引的存放时按照hash值的顺序排放的并不是按索引列的顺序排列，所以该索引不支持排序。
* 同样也不支持联合索引中的单项索引列查找，只支持等值查找不支持范围查找。

##### 联合索引

* 也就是多列（索引列值大于等于2）索引，在查询的时候需要考虑到最左前缀的问题。联合索引的还有一个好处是在第二个列值已经进行了排序。

##### 覆盖索引

* 覆盖索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
* 例如对单个字段的主键，或者`count(*)` 之类的统计操作，都是可以使用覆盖索引来完成的；

##### 聚簇索引（就是聚集索引）

* 聚集索引也称之为一级索引，一般通过主键来聚集数据，没有主键则使用非空的唯一索来做，没有则会隐式的建立一个主键来聚集数据。
* 把相关数据保存在一起，读取更方便。

###### 缺点

* 缺点就是每次被更新的行都需要移动其位置
* 导致二级索引过大，

##### 二级索引（辅助索引）

* 二级索引是指除了主键索引之外的其他索引，二级索引并不存储指向数据行的地址，而是存储的是主键值，根据主键值来查找到具体的数据行。

#### EXPLAIN 分析

| select_type | type | possible_keys | key  | key_len | ref  | Extra |
| ----------- | ---- | ------------- | ---- | ------- | ---- | ----- |
|             |      |               |      |         |      |       |

* 有的时候索引优化器没有选择索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表扫描来得到数据，这种情况多发生于范围查找。
* 例如：```select * from table where id >1000 and id <2000``` 这里不会采用 覆盖索引，而是会采用聚集索引，因为覆盖索引完成之后需要回表查询，而回表之后的查询是离散读的。这个时候如果使用扫描聚集索引，顺序读的方式可能会更快一点。（前提是访问的数据量需要足够大，比如占比20%左右）
* 当然这里可以使用 force index 来强制指定使用某个索引。

##### MRR 优化

* 一个功能是更加辅助索引查询出数据之后，再根据主键进行排序，然后再访问聚集索引进行数据查找
* 另外一个功能是将查询条件进行合并或者拆分，以避免读取多余的数据

##### Index Condition Pushdown 优化

* 将过滤条件查询放在了存储引擎层面，在取出索引数据的同时进行数据过滤


### 锁

#### 数据库的锁

* mysql innoDB 是支持行级锁和表锁的。

```mysql
# 一种共享锁，其他事务可以对其进行读取，但不可修改
SELECT ... LOCK In SHARE MODE;
# 这是属于悲观锁的一种，排他锁，其他事务不可读写
SELECT ... FOR UPDATE;
```

* 数据库还可以实现乐观锁，更新前先检查数据是否是自身所认为的那样。

```sql
update user set a=3 where a=2;
```

#### 一致性非锁定读问题

* 通过多版本控制来实现一致性非锁定读取，但是只在 可重复读的事务隔离级别下是有效的。

#### 一致性锁定读

* 该问题则是通过innodb 所支持的行级锁`select ... for update`, `select ... lock in share mode` 的模式来实现的

#### 锁的算法分类

##### Record Lock （锁定单个记录）

##### 间隙锁（锁定一个范围，但是不包含记录本身）

##### Next-Key-Lock（锁定一个范围，并且锁定记录本身，主要是为了解决幻读问题）

对于Next-Key-Lock 这种锁定方式来说，在查询的条件中如果存在唯一索引列的话，那么会自动降级为RecordLock 锁。

```mysql
select * from tab where a=3 for update;
// a 是辅助索引的话，那么会锁定 a的上一个索引值～3 和 3~a的下一个索引值
```

#### 锁带来的问题

* 脏读，幻读，更新丢失

#### 三级锁协议

* 对数据修改之前，该事务必须对起数据行加排它锁，这样可以避免修改的数据被覆盖。
* 在修改数据之前加排它锁也可以避免脏读的问题
* 在读取数据之前必须加读锁，可以解决不可重复读的问题，但是无法解决幻读的问题，这个问题可以由MVVC 来解决。

#### 并发版本控制问题

* InnoDb 变相的是基于数据快照的方式来实现行级锁，对每行数据都新增了两个字段，分别是创建时间和删除时间，而且还保存了当前事务的版本号。只有当前事务id> 该版本号才可以对其进行读取。
* 每次插入，或者删除都会生成新的版本号，每次查询都只会读取当前事务版本号之前的数据

### 复制

* 主库在每次更新数据的的sql事件记录在二进制文件当中。
* 从库会有两个线程，一个IO线程负责连接主库，同时主库还有有个线程来监听日志文件的变化，一旦有变化便会通知从库的读取的IO进程，将主库的日志文件写入从库中的中继日志文件.另外还有一个SQL线程用于执行中继文件中的sql,用于回放数据文件。

#### 快照和备份

* 复制功能可以用来做备份，但其功能不仅限于备份，还可以做读，写分离以减少主库的压力。
* 复制不能完全替代备份功能（因为主库的删除操作也会同步到从库，导致数据被删除），完整的备份功能需要再从库上执行 快照备份操作。

