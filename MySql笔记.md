[TOC]

## MySql 相关阅读笔记

### 实现细节

* 如何写入数据？（要区分写的是否是非唯一性的辅助索引）
* 如何主从复制？
* 如何读写分离？
* 如何分库分表？
* https://www.cnblogs.com/aspirant/p/9177978.html

### 日志文件

**二进制文件（binaryLog）**：

* 记录了所有对该数据库执行更改操作具体过程。主要用于**数据恢复，主备之间的复制**，以及操作审计之类的。二级制日志是在事物**提交之前**进行提交，只写入磁盘一次，不论这时事物大小。
* 记录的是关于一个事务的具体操作内容，属于是逻辑日志。

1. 每当开启一个事务的时候，每个会话会分配一个binlog_cache_size 大小的缓存，如果该事务的二进制日志大于该缓冲值的话，则会先写入一个临时缓冲文件，当事务提交的时候将该缓存写入二级制日志文件，所以该缓存的代销不能设置太大，默认32k.

2. 参数sync_binlog是用来控制每写多少次缓冲文件，就将文件同步到磁盘中，如果需要高可用则最后设置为1，表示每次都同步写入磁盘文件。

3. 会引入额外的问题，当二进制日志已经写入成功，但是事务并没有提交成功的话，事务不会被回滚，这个时候可以设置innodb_support_xa=1 来解决该问题。

4. binlog_format 参数: 代表二进制日志的格式，可选STATEMENT,ROW,MIXED 。

   STATEMENT: 简单记录SQL语句，会产生主从不一致的情况，比如使用了RAND()、uuid() 函数等，还会导致更新丢失问题。

   ROW: 记录行的更改情况，对磁盘空间要求高

   MIXED：综合的，会更加不同的情况选择不同的格式

5. 二进制日志可以通过mysqlbinlog 来查看二进制日志文件的内容。

**重做日志文件（redoLog）：**

  只记录与该存储引擎相关的事物日志。且重做日志记录的是每个页的更改情况，比如在某个偏移量插入了什么数据。重做日志是在事物执行的过程中被不断的被写入。

1. 重做日志在每个日志组中有两份文件，logfile1、logfile2 在写重做日志文件的时候回轮流写入。

2. 重做日志的写入并不是直接写入文件，而是先写入一个redo_log_buffer 缓冲池当中，然后再按一定顺序写入日志文件。

3. 写入日志文件的时候是按扇区大小进行写入的，512字节，所以可以保证写入的原子性。

4. 重做日志写入磁盘文件：首先在master Thread 内，每秒会进行一次写入，还有由innodb_flush_log_at_trx_commit 参数控制。

   | innodb_flush_log_at_trx_commit | 代表含义                                                     |
   | :----------------------------- | ------------------------------------------------------------ |
   | 0                              | 事务提交时不写入磁盘文件，等待主线程每秒的主动刷新           |
   | 1                              | 表示在提交时将日志缓冲写入文件，并且调用fsync                |
   | 2                              | 表示将重做日志写入文件，但是不会调用fsync 由操作系统进行同步 |

   还有就是当log buffer 中有一半的内存空间已经被使用时

5. 重做日志的恢复，mysql 是一个二阶段的提交模式，redoLog 的写入只是第一阶段，而进制日志的写入是第二阶段，所以即使写入了重做日志，但是事务没有提交就宕机了，在恢复的时候重做日志会检测到某些更改在二进制日志中不存在，所以抛弃掉。

### 事务

* 事务被认为是不可分割的最下隔离单元，但提到事务就必须会谈到其四大特性: 原子性，隔离性，一致性，持久性。
* 事务的持久性保障主要是依赖操作日志，任何修改数据的操作都会被记录操作日志，持久化至磁盘当中。

#### 隔离级别

* 未提交读、提交读、可重复读(MySql的默认隔离级别)、序列化串行读。

#### 并发下存在的问题

* 脏读：读取了其他线程还未提交的数据，比如A 修改了数据，B读取了其修改后的数据，但是A 又回滚了，导致B 读取到的其实是脏数据。
* 幻读：A线程 在第一次读取 和第二次读取直接，读取了B 线程新插入的数据，造成两次结果集合不一致的问题。
* 不可重复读：与幻读类似，但主要是针对另外一个事务对数据进行了修改。

#### 什么是幻读？

* 幻读是在`可重复读`的事务隔离级别下会出现的一种问题，简单来说，`可重复读`保证了当前事务不会读取到其他事务已提交的 `UPDATE` 操作。但同时，也会导致当  前事务无法感知到来自其他事务中的 `INSERT` 或 `DELETE` 操作，这就是`幻读`。

#### 数据库的锁

* mysql innoDB 是支持行级锁和表锁的。

```mysql
# 一种共享锁，其他事务可以对其进行读取，但不可修改
SELECT ... LOCK In SHARE MODE;
# 这是属于悲观锁的一种，排他锁，其他事务不可读写
SELECT ... FOR UPDATE;
```

* 数据库还可以实现乐观锁，更新前先检查数据是否是自身所认为的那样。

```sql
update user set a=3 where a=2;
```

#### 回滚日志


#### 间隙锁


#### 三级锁协议

* 对数据修改之前，该事务必须对起数据行加排它锁，这样可以避免修改的数据被覆盖。
* 在修改数据之前加排它锁也可以避免脏读的问题
* 在读取数据之前必须加读锁，可以解决不可重复读的问题，但是无法解决幻读的问题，这个问题可以由MVVC 来解决。

#### 并发版本控制问题

* InnoDb 变相的是基于数据快照的方式来实现行级锁，对每行数据都新增了两个字段，分别是创建时间和删除时间，而且还保存了当前事务的版本号。只有当前事务id> 该版本号才可以对其进行读取。
* 每次插入，或者删除都会生成新的版本号，每次查询都只会读取当前事务版本号之前的数据

#### 存储过程

* 预先定义好的一组sql 语句集合，预先编译好，执行速度快省去了客户端的连接时间。

#### 视图

* 视图的作用主要预设值一个虚拟表，虚拟表的数据与真实表同步。比如有一个复杂的查询语句，这样可以设置一个视图，然后每次查询只需要查询该虚拟表即可。

#### 分区表

* mysql 支持如下几种分区range、list、hash、key ，无论创建哪种类型的分区，如果表中存在唯一索引列时，分区列必须是唯一索引列的一部分。
* **RANGE 分区**

```sql
-- 创建表，设置分区，id<10 的存储在p1 分区
create tabel test(id int primary key) 
partition by RANGE(id) partition p1 values LESS THAN (20)
```

* **LIST 分区**

```mysql
create tabel test(
    id int primary key
) engine=innodb
partition by LIST(id) partition p1 values IN (3,20)
```

* 在分区表下面还可以有子分区
* **HASH 分区** 对于是否能将数据平均分散到各个分区，这取决于分区值是否是连续分布的。

```mysql
create table user(
a int,
b datetime
) engine=innodb
partition by HASE (year(b))
partitions 4
```

* **KEY 分区** 和HASH 分区一致，只不过分区用的方法是数据库自带的，PASWORD()

* 除此之外还有 **COLUMNS 分区**， 对应其他几种分区都得保证分区列时整形，或者计算之后是整形，单COLUMNS 分区不需要考虑。

#### 触发器

* 针对 insert、update、delete 的事件监听，来触发运行一段sql 集合。

### 索引

#### InnoDB 索引结构

* **值得注意的是 B+ 数索引并不能直接找到指定的数据，只能找到数据所在的页，然后把该页加载到内存中，在内存中进行查找**
* **页的大小是16kb,加载页完成之后再通过 再通过二叉查找找到数据。**

##### 索引的管理

* alter table index xxx ,和create index xxx。
* 一般需要创建一张新的临时表，然后进行数据迁移，最后再改表名。
* 对于辅助索引的创建，会对表加一个S锁，对于主键的创建好删除需要新建一张数据表。

**Cardinality值的计算**： 该值代表着数据在表中的重复率，也就是说 Cardinality/total 应该越接近1最好，该值是通过随机采用的方式来计算得出的。

##### B树

* B 树： B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构 .
* B 树同样保持着左子树小于当前节点，右子树大于当前节点的排列顺序。
* B 树的每个节点都保存着 `当前关键字数据的指针，叶子节点的指针`，并且所有叶子节点都在同一层。
* B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了 ,这样来说对于一颗树的层级就减少了，这样查找速度会更快

##### B+ 树

* B+ 树： B+ 树是在B树的基础上改进的一种数据结构。
* B+跟B树不同B+树的 **非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加，层数就会更加少
* B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
* B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
* 非叶子节点的子节点数=关键字数（来源百度百科）虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）
* 在进行全表扫描的时候，只需要扫描所有叶子节点即可，速度会更快。

##### 聚集索引、辅助索引

* 聚集索引与辅助索引都是B+树构成的高度平衡树，叶子节点存放着所有的数据，聚集索引与辅助索引不同点在于**叶子节点存放的是一整行的信息**。
* 聚集索引是按照数据库**主键来构造**的一棵B+数，按顺序存放。**聚集索引叶子节点存放的就是一行的完整数据，可以直接找到指定数据行** 
* 聚集索引也称之为一级索引，一般通过主键来聚集数据，没有主键则使用非空的唯一索来做，没有则会隐式的建立一个主键来聚集数据。

###### 缺点

* 缺点就是每次被更新的行都需要移动其位置
* 导致二级索引过大，

* **辅助索引(就是非聚集索引)，每个叶子节点只包含了键值，和指向聚集索引的键**， 一般的非主键索引的查找顺序是先通过辅助索引查找到叶子节点，该叶子节点存有指向聚集索引数据的键值。

##### 哈希索引( 对应Innodb 而言 哈希索引是自适应的，不能人工干预)

* **使用索引列全值作hash值来索引数据，只存在精确匹配**。如果出现不同数据行hash值一致的话，则会以链表的方式存放多个记录指针。
* 哈希索引只存储哈希值和行的指针而不存储字段值
* 哈希索引的存放时按照hash值的顺序排放的并不是按索引列的顺序排列，所以该索引不支持排序。
* 同样也不支持联合索引中的单项索引列查找，只支持等值查找不支持范围查找。

##### 联合索引

* 也就是多列（索引列值大于等于2）索引，在查询的时候需要考虑到最左前缀的问题。联合索引的还有一个好处是在第二个列值已经进行了排序。

##### 覆盖索引

* 覆盖索引包含了所有满足查询所需要的数据，查询的时候只需要读取辅助索引而不需要再进行聚集索引的检索；
* 例如对单个字段的主键，或者`count(*)` 之类的统计操作，都是可以使用覆盖索引来完成的；

##### 全文索引

* Innodb 每张表只能有一个全文索引

* 与B+ 树索引类似的是，全文索引采用 FullText 来创建Sql 语句如下

```sql
CREATE TABLE posts (
  id int(4) NOT NULL AUTO_INCREMENT,
  title varchar(255) NOT NULL,
  post_content text,
  PRIMARY KEY (id),
  FULLTEXT KEY post_content (post_content)
);
```

* 查询模式有Natural Language，模糊匹配

```sql
select * from table where match(body) against ('test')-- 查询body 字段中含有 test 单词的记录。
```

* Boolean模式(**+ 表示word必须存在，-表示word** 必须排除，@distance 表示查询多个单词之间距离)

```sql
select * from table where match(body) against ('+Pease -host' in boolean mode)
```

##### 二级索引

* 二级索引是指除了主键索引之外的其他索引，二级索引并不存储指向数据行的地址，而是存储的是主键值，根据主键值来查找到具体的数据行。

#### EXPLAIN 分析

| select_type | type | possible_keys | key  | key_len | ref  | Extra |
| ----------- | ---- | ------------- | ---- | ------- | ---- | ----- |
|             |      |               |      |         |      |       |

* 有的时候索引优化器没有选择索引去查找数据，而是通过扫描聚集索引，也就是直接进行全表扫描来得到数据，这种情况多发生于范围查找。
* 例如：```select * from table where id >1000 and id <2000``` 这里不会采用 覆盖索引，而是会采用聚集索引，因为覆盖索引完成之后需要回表查询，而回表之后的查询是离散读的。这个时候如果使用扫描聚集索引，顺序读的方式可能会更快一点。（前提是访问的数据量需要足够大，比如占比20%左右）
* 当然这里可以使用 force index 来强制指定使用某个索引。

##### MRR 优化

* 一个功能是更加辅助索引查询出数据之后，再根据主键进行排序，然后再访问聚集索引进行数据查找
* 另外一个功能是将查询条件进行合并或者拆分，以避免读取多余的数据

##### Index Condition Pushdown 优化

* 将过滤条件查询放在了存储引擎层面，在取出索引数据的同时进行数据过滤

### 复制

* 主库在每次更新数据的的sql事件记录在二进制文件当中。
* 从库会有两个线程，一个IO线程负责连接主库以便读取主库的二进制日志并且将其保存为中继日志文件，同时主库还有有个线程来监听日志文件的变化，一旦有变化便会通知从库的读取的IO进程来读取，另外还有一个SQL线程用于执行中继文件中的sql,用于回放数据文件。

#### 快照和备份

* 复制功能可以用来做备份，但其功能不仅限于备份，还可以做读，写分离以减少主库的压力。
* 复制不能完全替代备份功能（因为主库的删除操作也会同步到从库，导致数据被删除），完整的备份功能需要再从库上执行 快照备份操作。

##### 集群模式

1. 一主多从（slave 对master 的复制是一个瓶颈）
2. 多主一从  (将多个主库的数据备份到一个从库)
3. 双主复制（双主节点互为主备复制）
4. 级联复制（一个主节点负责一个从节点的复制，其余从节点从该从节点负责，依次类推）

#####　主从复制模式

1. 异步模式(默认的实现，由单独的子线程负责二进制日志文件的同步及应用)
2. 半同步模式：需要至少等到一个从服务器同步完成之后才会返回给客户端
3. 全同步模式：需要等到所有的从服务器回复写入到了relay log 才会返回给客户端，性能最差。



#### 热备

* 通过ibbackup 来完成备份

#### 冷备

* 复制备份相关的数据文件

#### 逻辑备份

