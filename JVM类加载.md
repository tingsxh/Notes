[TOC]

## JVM 类加载机制

### 加载

* 通过一个类的全限定名来获取定义此类的二进制字节流。
* 将二进制字节流转化为JVM方法区运行时的数据结构。
* 在内存中生成一个代表这个类的的Class 对象，作为方法区这个类的各种数据的访问的外部入口。
* 加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，

* 类的加载分为 **加载，链接（准备，验证，解析），初始化**。这几个阶段并没有完全的顺序关系，例如解析阶段可能会发生在 初始化阶段之后再进行（那么解析阶段到底是做什么事情呢？下面记录）。


#### 类的主动使用

* 而类的加载并没有规定具体执行的时间，但是 加载，准备，验证这几个阶段肯定是需要放在 初始化阶段之前的。那什么时候会触发一个类的初始化阶段呢？这个JVM规定了5种情况，分别是如下
  * 使用new 新建一个对象，或者调用一个类的静态方法，或者设置或获取一个类的静态字段（getStatic,putStatic,invokeStatic）
  * 使用反射创建对象的时候
  * 当初始化一个类发现其父类还未初始化的时候，会优先触发其父类的初始化(**这里需要注意，对于接口而言，并不成立**，但是在jdk8 中如果定义了默认方法则情况不同)
  * 虚拟机启动时会指定一个包含main 方法的类，虚拟机会首先初始化这个类。

#### 类的被动使用

* 以上记录的四种情况，称之为对类的主动使用，这些都是会触发类的初始化的。当然除此之外还有就是类的被动使用。
  * 通过子类访问父类的静态属性(包括字段和方法)的时候，是不会触发子类的初始化的。
  * 还有就是访问一个类的静态常量值的时候，会在编译期通过优化将常量存放在调用方的常量池中。
  * 还有就是数组类型初始化的时候。

#### 数组类的加载

* 对于类的加载阶段，可以分两种情况来讨论：一个是普通class类的加载，还有一类是数组类型的加载，如int[] 数组类并不是有类加载器实现加载的，而是有虚拟机直接进行加载的，在对数组类的加载过程中，jvm做了如下几个规定
  * 首先每个被加载的类，都必须要与一个类加载器相关联以确保唯一性(换句话说，就是一个类其实是可以被不同加载器重复加载多次的)。
    * 但jvm在处理 数组类加载但过程中会有如下判断，首先是判断数组的组件类型(就是数组去除一个维度之后的数据类型) 是否是引用类型，例如A[] 的组件类型为A 。如果是的话那么A将由正常的类加载去加载。并且A[] 数组将和该加载相关联。当然这里需要注意一下，如果是多维数组，其对外表现上还是一个一维数组，只不过里面的内容还是一个数组类型而已，对于多维数组的加载，将会递归上述的加载方法。`A[][]-->A[]-->A` 这样一个步骤。
    * 如果不是的话，例如 int[] ，则将该数组与启动类加载器关联绑定。

### 验证

#### 文件格式的校验

* 字节码的魔数是否正确，版本号是否在该jvm版本允许范围内
* 常量池中是否含有非法字符引用

#### 元数据的验证

* 类的继承情况是否正常，是否都含有父类，是否继承了final类
* 是否重载非法，例如参数相同，但返回类型不一致的情况。
* 检查java语义是否正确。

#### 字节码的验证

* 这里的校验非常复杂，例如校验跳转是否合法，赋值操作是否合法。

* 为了提升字节码校验的效率，Code属性表中增加了一项`StackMapTable` 属性，用于方法体中，开始时本地变量表和操作数栈的状态，这样就不用去遍历整个方法体来检查了。

  javap命令看看它的字节码指令

#### 最后还有一个符号引用的验证

* 这个校验发生在解析阶段，主要是判断符合引用中的全限定名是否能找到响应的类信息，方法字段是否存在
* 需要注意的是，验证阶段并非必须的，可以使用启动参数屏蔽该操作

### 准备

* 准备阶段只是给类变量赋上初始值，类变量指的是被`static`修饰的字段，例如int 类型的初始默认值是0。
* 但是有一种情况除外，如果在类字段的属性表存在`ConstantValue` 表示常量的时候，（被final 修饰的常量）那么该字段则会在准备阶段直接赋予所设置的值，也即是`ConstanValue`所指定的值。

### 解析

* 解析过程主要的工作就是将符号引用替换为直接引用，那么这里需要理解下这两个概念：
  * 符号引用：：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可
  * 直接引用：简单说来就是可以直接执行目标的指针，比如存储在堆中类，字段
* 解析主要分为 类和接口的解析以及字段的解析，类和接口中的方法的解析
* 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7 类符号引用进行

##### 类或接口的解析

* 

##### 字段的解析

* 先解析该字段所属的类或接口的符号引用，如果这个类之间含有字段描述符的话那么直接返回，否则还需要逆向检索该类的父类，接口进行查找。

##### 方法的解析

* 

### 初始化

* 初始化的过程主要是执行一个`<clinit>` 方法，这个方法是由虚拟机自动生成的，生成的规则是按照书写的前后顺序，将静态字段，静态代码块放在这个初始化方法中。
* 需要注意的是，**在静态代码块中只能使用在它之前定义的静态字段，但是可以给它后面定义的字段进行赋值操作**。
* 关于继承关系下这个方法的执行特性，**对类而言，子类的初始化一定会触发父类的初始化方法**，并且不需要显示调用。对于接口之间，不存在这种关系，在上面的加载过程一件强调过这层关系了。
* 但这个初始化方法却并不是必须的，如果不存在静态字段或代码块，则完全可以不生成。

### 类加载器

* 类的加载器主要分为三大类 

* **启动类加载器(JVM 自带，由C++实现，主要加载JAVA_HOME\lib)、rt.jar、tools.jar**

  如果需要让启动类加载器加载的化，getClassLoader() 直接返回null 即可

* **扩展类加载器**（ExtClassLoader ）

  负责加载 `JAVA_HOME\lib\ext` 目录下的

* 应用程序加载器（AppClassLoader）

  负责加载用户类路径classpath 上所有的类库。

### 双亲委派

* jvm虚拟机的类加载机制是使用双亲委派的机制来实现的，简单介绍就是，每一个类加载器(自定义的或者是系统自带的) 接收到一个类加载到请求，首先需要交给它的父类去加载，父类也依次类推，如果最顶层父类(启动类加载器)可以加载则由启动类加载器加载，否则的话就逐次降级到次父类加载器，直到交给自身来加载为止。
* 双亲委派到好处在于，维护了jvm系统类能够不被破坏。例如程序员自定义的与系统类重名的java.lang.Object 是无效的，不会被系统所加载。

* 双亲委派也是会被破坏的。

#### 双亲委派模型的破坏

* 父类不感知之类的具体实现，只有依靠子类的应用程序类加载器来加载，例如SPI 功能，JDBC 功能，这些都是通过秀暗藏上下文类加载器来实现的逆向加载。
