### mysql 索引失效的情况

* 没有遵循最左前缀规则，比如 like %开头，对于联合索引的话，如果跳过开头的索引字段也会导致索引失效
* 使用 or 的条件下会导致索引失效
* not in 会导致索引失效

### 主从同步

* 主从同步也就是主从之间的二进制日志文件复制过程，这个过程是异步的且是有从服务器发起的
* 在从服务器存在两个线程，一个是负责连接主服务器读取二进制日志文件的线程，读取到二进制文件，将其保存到从服务器的中继日志里。除此之外还有一个就是sql 线程，负责执行中继日志将sql 应用到服务器中。

### sql 优化手段

* 加索引是基本的
* 然后尽量使用覆盖索引，因为不需要回表查询。

### 乐观锁、悲观锁

* 在实现可重复读的隔离级别低时候，以及更新，删除数据的时候其实就使用了乐观锁
* 非阻塞性的控制锁，一般来说是通过版本号来控制
* 悲观锁一般是通过 select for update 如果查询条件是主键的话，那么则会锁住该行，否则会锁住整个单表

### NoSql 比较

* Memcached 可以利用多核优势，但是只能存储简单key/value 数据结构，且无法进行持久化
* redis 因为是单线程的，性能受到单CPU性能的限制

### 分布式session 问题

1. 利用nginx 会话保持技术，使得同一个ip用户每次请求到同一台机器上（后端服务挂了之后，造成会话丢失）
2. 利用分布式缓存管理seesion
3. 集群之间的seesion 同步

### 缓存更新时机问题

1. 先删除缓存再更新数据库

   场景：线程A 已经删除了缓存，还没来得及更新数据库，线程B开始查询，发现查询到的缓存不在，于是查询数据库老的数据，并且回写入缓存。

2. 先更新数据库再删缓存(**最优解**)

   同样存在问题，场景：线程A 查询数据库未命中，读取了数据库的老数据，此时线程C 发起了更新操作，导致缓存被清理了，然后线程A 顺利将老的数据更新到缓存中了，缓存中保存了脏数据。

3. 先更新数据库再更新缓存

   场景：线程A 更新数据库，线程B 更新数据库，线程B 更新缓存，线程A 更新缓存 导致线程B的正确缓存被覆盖

4. 只更新缓存，然后异步的更新数据库

### 负载均衡的几种策略

* 轮询
* 随机
* 权值
* ip_hash
* least_coon

### 雪花算法

* 采用时间戳+机器码+机房码

### 高并发相关

* 缓存，熔断降级，限流
* 缓存和熔断降级 是解决单个服务不可用问题从而影响全局的解决办法
* 但是对于大流量的请求，熔断降级不能解决，只有通过在上层做限流措施来解决。

#### 限流算法

* 令牌桶算法（限制一定程度的请求并发数，速率是在指定范围内可控的）Guava 的RateLimiter 提供的令牌桶算法可用于平滑突发限流。

* 漏桶算法（平均速率限流算法，限制请求的速率）

* 计数器算法（限制总并发数，比如线程池大小，连接池大小，秒杀并发数）

* 分布式限流如果扛不住的话，可以进一步改为应用级限流。

* 业务层限流和接入层限流，在nginx 通过limit_conn 模块进行限流

#### 服务降级

* 对于读服务降级一般采用的策略有，切换读缓存（对一致性要求不高，页面降级走静态页面）
* 对应写缓存降级，可以改为先写缓存再同步修改DB,当DB扛不住的时候降级为异步写DB.

#### 多级降级

* 页面降级，接入层降级，应用层降级开关

#### 配置中心

* 

  

