## Redis 笔记



### 如何保障数据的持久性

#### 快照备份(默认实现)

* 由使用者自行决定，可以设置在n秒内有m个键值被改变了则进行一次数据快照备份。数据备份的具体过程是，主进程会fork 一个子进程出来，将内存中的数据写入到磁盘的临时文件中，当写完了之后再替换掉原来的快照文件。
* 这种方式由一个缺点就是每次都会全量大覆盖快照文件，而且会出现丢失一部分数据的情况。
* save 设置 Redis 进行数据库镜像的频率,将数据进行磁盘备份写入。

#### AOF 文件模式

* 具体实现逻辑是将每个写的指令都直接写入磁盘文件，在数据库重启的时候按照写的命令重新复原一次数据即可。

* 为了解决操作系统写入的实时性，可以通过如下参数来设置 appendfsync，保证写入数据的实时性。

* 除此之外aof 的问题在于 数据文件会过大，比如 100个 inr自增大命令，就会形成100条指令，但其实可以简化为1条指令。因此redis 还有bgrewriteaof 命令。

* bgrewriteaof 的实现方式和快照写入但实现方式一致，从主进程fork 出一个子进程，将内存中的值写入临时文件，再做文件替换。

* 而父进程继续处理 client 请求，除了把写命令写入到原来的 aof 文件中。同时把收到的写命 令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。

* 子进程写完之后，再通知父进程把缓存的命令写入新的文件中。这样就解决了文件过大的问题

  

### redis 如何实现主从复制

* 只需要在从库的配置文件添加 slaveof xxxx 6379 指明当前从库的主库地址
*  masterauth 指定主库的密码。

### 事务以及乐观锁实现

#### 事务基本操作 Multi

* 因为redis 是单线程运行的，所以其事务是实现是，将同一事务中的所有操作指令预先存储至队列，当从此连接 受到 exec 命令后，redis 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 client.然后此连接就 结束事务上下文。但是redis 是不具有回滚操作的，只能做到给客户端返回整体的执行状态。但是事务的安全性没法保证，其他的连接依然可以修改事务涉及到的数据。

#### 事务的安全性 watch

* 对于事务的安全性控制，redis 可以使用watch 操作来实现，在进行事务之前。但是 [WATCH] 只能在客户端进入事务状态之前执行， 在事务状态下发送 [WATCH](http://redis.readthedocs.org/en/latest/transaction/watch.html#watch) 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 [MULTI]的情况一样）。
* 因为上述原因，redis 的事务只能保证 一致性和隔离性，并不能保证持久性和原子性。