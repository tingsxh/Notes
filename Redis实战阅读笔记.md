[TOC]

## Redis 笔记

### 数据库的结构

- 数据库主要由 `dict` 和 `expires` 两个字典构成，其中 `dict` 保存键值对，而 `expires` 则保存键的过期时间。
- 还有一个id 域，用于切换数据库使用。

#### 执行流程

- 服务器通过文件事件无阻塞地 `accept` 客户端连接，并返回一个套接字描述符 `fd` 。
- 服务器为 `fd` 创建一个对应的 `redis.h/redisClient` 结构实例，并将该实例加入到服务器的已连接客户端的链表中。
- **服务器在事件处理器为该 `fd` 关联读文件事件**，服务器通过读事件来处理传入数据，并将数据保存在客户端对应的`redisClient` 结构的查询缓存中。
- 根据客户端查询缓存中的内容，程序从命令表中查找相应命令的实现函数，程序执行命令的实现函数，修改服务器的全局状态 `server` 变量，并将命令的执行结果保存到客户端 `redisClient` 结构的回复缓存中，**然后为该客户端的 `fd` 关联写事件**
- 当客户端 `fd` 的写事件就绪时，将回复缓存中的命令结果传回给客户端。至此，命令执行完毕

#### 跳跃表的实现

### 如何保障数据的持久性

#### 快照备份(默认实现)

* 由使用者自行决定，可以设置在n秒内有m个键值被改变了则进行一次数据快照备份。数据备份的具体过程是，主进程，会fork 一个子进程出来，将内存中的数据写入到磁盘的临时文件中，当写完了之后再替换掉原来的快照文件。
* 这种方式由一个缺点就是每次都会全量大覆盖快照文件，而且会出现丢失一部分数据的情况。
* save 设置 Redis 进行数据库镜像的频率,将数据进行磁盘备份写入。

#### AOF 文件模式

* 具体实现逻辑是将每个写的指令都直接写入磁盘文件，在数据库重启的时候按照写的命令重新复原一次数据即可。

* 为了解决操作系统写入的实时性，可以通过如下参数来设置 appendfsync，保证写入数据的实时性。

* 除此之外aof 的问题在于 数据文件会过大，比如 100个 inr自增大命令，就会形成100条指令，但其实可以简化为1条指令。因此redis 还有bgrewriteaof 命令。

* bgrewriteaof 的实现方式和快照写入但实现方式一致，从主进程fork 出一个子进程，将内存中的值写入临时文件，再做文件替换。

* 而父进程继续处理 client 请求，除了把写命令写入到原来的 aof 文件中。同时把收到的写命 令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。

* 子进程写完之后，再通知父进程把缓存的命令写入新的文件中。这样就解决了文件过大的问题

### Redis 如何实现主从复制

* 只需要在从库的配置文件添加 slaveof xxxx 6379 指明当前从库的主库地址，如果需要密码的话 masterauth 指定主库的密码。
* 主库并不感知从库的存在，复制是从库主动连接主库，链接建立之后就开始了数据的复制，复制期间，主库会把写的指令存储在缓存区间内，复制结束后会把这部分缓存的指令同步给从库，之后主库的每一个写的指令都会主动发送给从库。

##### 全量复制

* 主从复制 需要 依赖  从节点复制偏移地址，主机点ID。全量复制的过程其实把主节点的快照文件返送至从节点，从节点收到之后存入磁盘再载入到内存当中。

##### 部分复制

* 主节点会维护一个缓存队列区间，主节点在接收写指令的时候也会把命令缓存至队列中。如果从节点中途中断了，则重新链接之后使用部分复制即可。

### 事务以及乐观锁实现

#### 事务基本操作 Multi

* 因为redis 是单线程运行的，所以其事务是实现是，将同一事务中的所有操作指令预先存储至队列，当从此连接接收到 exec 命令后，redis 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 client.然后此连接就 结束事务上下文。但是redis 是不具有回滚操作的，只能做到给客户端返回整体的执行状态。但是事务的安全性没法保证，其他的连接依然可以修改事务涉及到的数据。

#### 事务的安全性 watch

* 对于事务的安全性控制，redis 可以使用watch 操作来实现，在进行事务之前。但是 [WATCH] 只能在客户端进入事务状态之前执行， 在事务状态下发送 [WATCH](http://redis.readthedocs.org/en/latest/transaction/watch.html#watch) 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 [MULTI]的情况一样）。
* 因为上述原因，redis 的事务只能保证 一致性和隔离性，并不能保证持久性和原子性。

### Redis 的过期机制

* 虽然有那么多种不同单位和不同形式的设置方式， 但是 `expires` 字典的值只保存“以毫秒为单位的过期 UNIX 时间戳”， 这就是说， 通过进行转换， 所有命令的效果最后都和 [PEXPIREAT](http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat) 命令的效果一样。
* redis 默认实现是采用惰性删除结合定期删除的策略进行过期键值信息的管理的。
*  附属节点即使发现过期键，也不会自作主张地删除它，而是等待主节点发来 `DEL` 命令，这样可以保证主节点和附属节点的数据总是一致的。 
