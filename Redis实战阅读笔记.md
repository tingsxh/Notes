[TOC]

## Redis 笔记

### 数据库的结构

- 数据库主要由 `dict` 和 `expires` 两个字典构成，其中 `dict` 保存键值对，而 `expires` 则保存键的过期时间。
- 还有一个id 域，用于切换数据库使用。

#### 字符串结构

* 在数据量小的时候，比如小于等于32字节，那么字符串对象将使用embStr 编码方式来保存这个值，这种编码方式的优势在于内存分配次数少。

#### 列表对象

* 压缩列表和双端链表的实现

#### 集合对象

* 集合对象使用的编码是intset或者hashTable
* 当集合所有保存的对象都是整数值并且对象数量小于512个

#### 有序集合

* zset 的数据结构通常会采用ziplist 或者skiplist 的数据结构来实现
* 在跳跃表的实现过程里还存在一个dict 用于保存键值到分数值到映射关系

#### 字典的结构

* 通常会由ziplist 或者hashtable来实现，当所有键值对的键和值的长度读小于64字并且键值对数量小于512个

* 会存在两个hash 表的结构，h[0],h[1] 其中只会使用一个，另一个需要在rehash 的时候使用。

#### 哈希表的扩展与收缩

* 当有子进程在执行save 操作的时候，扩容操作所需要的负载因子系数为5，当没有子进程在执行操作的时候，扩容所需要的负载因子时1
* 当负载因子小于0.1 的时候，会触发缩容操作。

#### 渐进式hash

* 渐进式hash 的原理就是一步步将h[0] 上的数据迁移至h[1]上。

#### 跳跃表的实现

* 其实是链表的一个扩展，在有序链表的基础上增加了一层或多层索引项文件，类比做书的目录，比如章节，小节之类的页数定位。

### 如何保障数据的持久性

#### 快照备份(默认实现，RDB文件模式)

* 由使用者自行决定，可以设置在n秒内有m个键值被改变了则进行一次数据快照备份。数据备份的具体过程是，主进程，会fork 一个子进程出来，将内存中的数据写入到磁盘的临时文件中，当写完了之后再替换掉原来的快照文件。
* 这种方式由一个缺点就是每次都会全量大覆盖快照文件，而且会出现丢失一部分数据的情况。
* save 设置 Redis 进行数据库镜像的频率,将数据进行磁盘备份写入,save 是阻塞住进程的，bgsave 是非阻塞主进程的。
* RDB 文件模式是记录当前内存中的键值对数据来进行持久化的。

#### AOF 文件模式

* 具体实现逻辑是将每个写的指令都直接写入磁盘文件，在数据库重启的时候按照写的命令重新复原一次数据即可。
* 为了解决操作系统写入的实时性，可以通过如下参数来设置 appendfsync，保证写入数据的实时性。
* 除此之外aof 的问题在于 数据文件会过大，比如 100个 inr自增大命令，就会形成100条指令，但其实可以简化为1条指令。因此redis 还有bgrewriteaof 命令。
* bgrewriteaof 的实现方式和快照写入但实现方式一致，从主进程fork 出一个子进程，将内存中的值写入临时文件，再做文件替换。

##### AOF 重写原理

* 重写原理主要是为里解决aof 文件过大的问题，那最有效的方式其实是读取当前数据库中的键的值，再用一条写入命令记录到aof 数据库文件当中，而不得去分析aof 文件再进行整合。

##### 后台重写

* 而父进程继续处理 client 请求，除了把写命令写入到原来的 aof 文件中。同时把收到的写命令写入到aof 重写缓冲区文件里面，这样做的目的主要是为了收集在重写过程中产生的新的写入指令产生，导致aof文件和当前数据库状态不一致的情况。
* 子进程写完之后，再通知父进程把缓存的命令写入新的文件中，父进程收到通知信号之后，父进程会将aof重写缓冲区里的内容再追加写入到aof文件中，再执行文件覆盖。

#### IO 多路复用

##### 执行流程

- 服务器通过文件事件无阻塞地 `accept` 客户端连接，创建并返回一个套接字描述符 `fd` 。
- 服务器为 `fd` 创建一个对应的 `redis.h/redisClient` 结构实例，并将该实例加入到服务器的已连接客户端的链表中。
- **服务器在事件处理器为该 `fd` 关联读文件事件**，服务器通过读事件来处理传入数据，并将数据保存在客户端对应的`redisClient` 结构的查询缓存中。
- 根据客户端查询缓存中的内容，程序从命令表中查找相应命令的实现函数，程序执行命令的实现函数，修改服务器的全局状态 `server` 变量，并将命令的执行结果保存到客户端 `redisClient` 结构的回复缓存中，**然后为该客户端的 `fd` 关联写事件**
- 当客户端 `fd` 的写事件就绪时，将回复缓存中的命令结果传回给客户端。至此，命令执行完毕

##### 事件

* 文件事件，时间事件，都是由redis 主程序来处理
* 文件事件分为，读事件，写事件，连接事件。

##### 常见的多路复用算法，各有什么优缺点

* 

### Redis 如何实现主从复制

* 只需要在从库的配置文件添加 slaveof xxxx 6379 指明当前从库的主库地址，如果需要密码的话 master auth 指定主库的密码。
* 主库并不感知从库的存在，复制是从库主动连接主库，链接建立之后就开始了数据的复制，复制期间，主库会把写的指令存储在缓存区间内，复制结束后会把这部分缓存的指令同步给从库(保证同步的完整性)，之后主库的每一个写的指令都会主动发送给从库。

#### 数据同步

##### 全量复制(旧版本,SYNC)

* 旧版本的复制其实是全量复制加命令同步，全量复制的过程即从服务器向主服务器发送一个 sync 的命令，然后主服务器先执行 bgsave 命令生成全量的RDB文件，然后再把主节点的快照文件发送至从节点，从节点收到之后存入磁盘再载入到内存当中。

##### 部分复制(断线重连，PSYNC)

##### 主服务器偏移量，从服务器偏移量

* 主服务器和从服务器都自身维护着一个便宜量，当主服务器传播一定数量之后，变会自增，如果从服务器收到一定数量之后也会自增，如果一旦从服务器断线了，那么再次连接之后就和主服务器的便宜量不一致了，那么就需要从新进行增量同步了，增量同步的规则见下文

##### 复制积压缓冲区

* redis 服务端会维护一个固定大小的积压缓冲区，主要是解决断线重连的从节点如何快速复制的问题。当主节点在进行写命令传播的时候，也会将写命令缓冲至队列里面，特别注意的是，每个命令都会记录它相应的偏移量。
* 但是这种旧版本的效率十分低下尤其是在处理断线重连的过程中，会耗费大量的时间。

##### 服务器ID

* 每个节点都维护着自身的服务器id,在服务启动的时候会自动生成，每次从节点进行同步的时候都会保存着主节点的id,当断开重连之后，如果发现主节点变化了，则需要进行全量同步了。

##### 整体逻辑

* 从节点向主节点发送 psync 命令的时候，主节点先检查主节点id 是否一致，如果不一致的话则需要进行全量复制，如果一样的话再检查从服务器的复制偏移量是否在主节点的挤压缓冲区内，如果在的话则进行部分复制。

### 事务以及乐观锁实现

#### 事务基本操作 Multi

* 因为redis 是单线程运行的，所以其事务是实现是，将同一事务中的所有操作指令预先存储至队列，当从此连接接收到 exec 命令后，redis 会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到 一起返回给 client.然后此连接就 结束事务上下文。但是redis 是不具有回滚操作的，只能做到给客户端返回整体的执行状态。但是事务的安全性没法保证，其他的连接依然可以修改事务涉及到的数据。

#### 事务的安全性 watch

* 对于事务的安全性控制，redis 可以使用watch 操作来实现，在进行事务之前。但是 [WATCH] 只能在客户端进入事务状态之前执行， 在事务状态下发送 [WATCH](http://redis.readthedocs.org/en/latest/transaction/watch.html#watch) 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 [MULTI]的情况一样）。
* 因为上述原因，redis 的事务只能保证 一致性和隔离性，并不能保证持久性和原子性。

### Redis 的过期机制

* 虽然有那么多种不同单位和不同形式的设置方式， 但是 `expires` 字典的值只保存“以毫秒为单位的过期 UNIX 时间戳”， 这就是说， 通过进行转换， 所有命令的效果最后都和 [PEXPIREAT](http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat) 命令的效果一样。
* redis 默认实现是采用惰性删除结合定期删除的策略进行过期键值信息的管理的。
*  附属节点即使发现过期键，也不会自作主张地删除它，而是等待主节点发来 `DEL` 命令，这样可以保证主节点和附属节点的数据总是一致的。

#### Sentinel（哨兵模式）

* 如何监控主、从服务器

  sentinel 会以每十秒一次的频率向主服务器发送info命令，解析返回的信息从而获取主服务器下面的从服务器地址，以及服务器id 信息

##### 如何选举新的主服务器

  由一个领头的sentinel 负责进行故障转移操作。

  领头的sentinel 以集群共同选出，当集群已经通过相互之间通信确定了主服务器确实已经下线了之后，需要向其他sentinel 发出通知，以求选举出领头的sentinel。

  每个sentinel 节点都会要求另外的节点将自己设置为局部领头节点，但是sentinel 会按照顺序来处理，只响应第一个请求，后续的都会拒绝。

* 哨兵集群之间如何通信以及投票

  通过发送命令的形式

##### 故障转移

* 在剩下的从服务器内选举新的主服务器
* 将其他从服务器的主服务器地址指向新的主服务器地址
* 将旧的主服务器设置为新的主服务器的从服务器

##### 选举新的主服务器

* 由局部领头的snetinel 服务器选举出新的主服务器地址，

* 选取新的主服务器的规则有三个，先看服务器的优先级，再看服务器的复制偏移量也就是谁的数据最全，最好再根据服务器id进行排序(选出id最小的)

#### 集群模式

* 集群模式主要为了解决哨兵模式单主节点的性能瓶颈问题

* 多个主节点之间通过gossip协议来进行数据通信

##### 数据槽

* redis 数据库集群将数据分割为16384个集群，集群中的每个键都属于这个16384个槽中的一个，当所有的槽都有节点在处理时，集群处于上线模式，否则处于下线模式。
* 集群节点通过保存slots[] 数组来标记当前节点是否处理某个槽，如果处理的话则值为1，否则为0.
* 集群中每个主节点都会将自己所处理的槽信息发送给其他的主节点，并且自身也会保留所有槽对应的处理节点信息.

##### clusterState.slots

* 记录了每个槽对应的节点信息

##### clusterNode.solts

* 记录了每个节点对应的所有槽信息

##### 执行命令

* 因为每个主节点都知道每个槽对应的处理机器在哪里，所以如果当前请求执行的槽信息不在当前主机负责范围内的话，那么将会返回MOVED命令给客户的，并且引导其向指定的主机发起请求。
* 但是当一个主节点正在执行槽迁移的过程中，则会返回给客户的ASK错误信息，这是一种临时的处理策略。

##### 故障迁移


  

