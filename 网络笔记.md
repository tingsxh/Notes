## 网络知识点

### TCP

#### 三次握手

* A 为客户端，B 为服务端。首先A 发起一个连接请求带上 seq  number 传送给 服务端B
* 服务端B 收到A的请求之后，立即发送回一个消息带上seq number+1 和ACK=1 以及带上服务端生成的一个序列号SN
* 客户端A 收到服务端B 返回的信息之后，检查 sq Number 是否加1，以及ACK 是否为1，如果是则发送请求至服务端，带上自身的ACK=1,并且服务端序列号SN+1。服务端检查通过之后，连接建立。

##### 为什么不可以两次

* 两次的话，相当于没有第三次的确认。就相当于第二步服务端收到请求之后就直接建立连接了。这会出现当A->B 出现延迟的情况，然后A重新发起连接请求，就会导致服务端会出现空闲连接的情况，造成资源浪费。

#### 异常情况

* 不管任何一次的请求发送失败了，发送的一方都将会进行重试
* 如果客户端挂了，服务端则会发起探测性请求，一直探测失败则直接关闭连接。

#### 四次释放

* 客户端A发送断开请求至服务端B，带上序列号seq。
* 服务端B 接收到之后，发送ack=1 seq+1 返回给客户端，表示客户端不能再发数据给服务端了，但是还可以接收服务端的数据。
* 服务端再次发送一个序列号SN 给客户端，表示服务端不再发送数据给客户端。
* 客户端收到之后，将服务端序列号+1 并且将自身ACK=1 发送至服务端。服务端接收到之后关闭连接，客户端等待一等时间之后也自动关闭。

#### 为什么不可以三次

* 因为当服务端收到客户端关闭请求的时候，可能还有数据在传输中。

#### 滑动窗口

* 接收方和发送方都有一个滑动窗口，发送方的滑动窗口取决于接收方的滑动窗口大小。在建立连接之后，接收方会反馈自身的窗口大小。
*  接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

#### 拥塞控制

*  如果网络出现拥塞，发送方将会执行重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度 。
* 慢开始，拥塞避免，快重传，快恢复。
* 慢开始指的是，当接收到一个报文已经到达之后再翻倍传输大小。拥塞避免是指设定一个阈值，当大于阈值则每次只加一。

#### TCP VS UDP

* 有连接和无连接，区别在于发送数据之前是否需要先建立连接，UDP不需要先建立连接。而且UDP接收方接收数据之后不会给出答复。
* UDP 没有拥塞控制吗，当出现网络阻塞的时候，不会减少发送方的速率。
* 数据包校验，接收方会进行重复包数据的去重，发送发在未收到接收方的确认后会发起超时重传。
* 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
* 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

## 操作系统相关问题

* 多路IO 复用问题，同步和异步的区别主要是体现在对于事件结果的感知上，如果有通知回调则是异步反之为同步。
* 阻塞与非阻塞体现在事件触发之后，是否可以去做其他的事情。
* select 和poll 和 epoll 的一些区别
  - `select`：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，**开销大**），由内核根据就绪状态修改该集合的内容。（缺点2）**集合大小有限制**，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：**轮询的方式效率较低**），当文件描述符的数量增加时，效率会线性下降；
  - `poll`：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
  - `epoll`：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。
* 进程是资源分配的基本单位，线程是CPU 调度的基本单元。线程没有资源分配，可以直接使用父进程的系统资源，切换代价小。但是进程的切换代价。
* 