### 锁的笔记

#### synchronized

* synchronized，四种状态的转换
* 关于synchronized 的两个要点需要明白：`对象头` 以及`monitor`管程，每个对象都生来具有一把隐形锁，就是`monitor` 监视器。
* 对象的具体结构在这里不是重点。
* 在当前jdk8 里面`synchronized` 的前面几种锁状态都是依赖于锁对象头里面的`Mark Word`（标记字段） ，来进行`cas` 操作拿锁的，即使逐步膨胀为重量级锁也依赖于锁对象头里面的 `mark word` 字段来标记了，既然这个`mark word` 这么重要，那就有必要知道它到底是个啥东西了，如下：
* ![1569821826371](C:\Users\d00464537\AppData\Roaming\Typora\typora-user-images\1569821826371.png)

  * 当前锁对象是否处于偏向，是由`是否偏向` 那个标志为控制的, `锁的标志`则用来判断锁当前处于何种级别的锁状态中。

* 至于偏向锁是什么东西，简而言之就是（**我第一次获取了锁，我下次就不去获取锁了，直接判断下拿锁的人是不是我就好了，如果不是，我再尝试拿一次，拿不到我就升级**）

### 无锁到偏向锁

  * 偏向锁是针对于单线程运行情况下做的优化，在目前的jdk版本中，对象锁默认都是开启了可偏向状态的，线程第一次获取偏向锁的过程如下：

    * 首先判断对象是否为可偏向状态 即 锁的状态为**01**无锁状态以及是可偏向状态（标志位为1），

    * 如果是可偏向状态：

      * 那么就直接cas 操作将对象头MarkWord 中存储线程id 的位置替换为当前线程A。
      * 如果成功：
        * 说明已经成功获取偏向锁了，继续执行同步代码块。
      * 如果失败：
        * 说明此时已经有另外一个线程B 获取了锁,此时线程A应该是将锁对象升级为轻量级锁(就是偏向锁的撤销)。

    * 如果是已经偏向的状态：

      那么则需要检查锁对象头里面的线程id 是否和当前线程A一致。

      * 如果相等：则说明已经拥有偏向锁，直接执行同步代码即可
      * 如果不相等：则说明需要存在竞争，需要尝试重新偏向，或者偏向锁升级。

    * 如果是不可偏向状态，那么就直接以轻量级锁的方式来获取。

### 偏向锁的撤销 (升级)

  * 偏向锁的撤销是由尝试拿锁的另外一个线程B来触发的，撤销过程需要等到全局安全点上来执行。

  * 如上所诉，出现偏向锁撤销有两种情况(1.第一次抢锁失败，2.测试偏向锁是否偏向自身失败时)

  * 撤销分如下几步：

    1.先根据锁对象中记录的已经获取了锁的线程id,判断该线程是否还存活

    * 如果已经销毁：则直接将锁状态恢复为无锁状态且可偏向的状态（这样线程B 就可以以获取偏向锁的方式获取）
    * 如果线程依旧存活：1.则需要根据线程id找到相应的线程执行栈，再判断线程是后还持有该锁对象、
      * 如果继续持有，则需要将锁对象升级为轻量级锁，随便补齐轻量级锁需要的MarkWord指针重定向等等步骤。
      * 如果不再持有，则可以将锁恢复至（不可偏向的无锁状态，因为偏向锁过期了，等下一线程重新获取锁)。

    **锁升级的过程，等到GC达安全点的时候（将持有锁的线程挂起，并且修改锁的标识位为轻量级锁，状态码00），还有就是修改`mark word `指向 持有锁线程 线程栈中的`lock record`（锁记录）**，升级为轻量级锁之后，自身再加入`cas` 轻量级锁的竞争当中。

  * **偏向锁到轻量级锁**

  * cas 轻量级锁自旋拿锁的过程

  *  线程1获取轻量级锁时会先把锁对象的**对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间**（称为DisplacedMarkWord），然后**使用CAS把对象头中的内容替换为线程1存储的锁记录（**DisplacedMarkWord**）的地址**； 

  * 如果替换成功了，这才算是成功获取锁咯，再进一步把MarkWord中的锁标记设置为`00` 表示处于轻量级锁定状态。

  * 如果替换失败了，再进一步检查当前对象头是否指向当前线程的MarkWord,如果是，则重入锁。因为**对应轻量级锁, 线程首先会创建一个lock Record 的线程栈，用于存储mark word 的拷贝，每一个被加锁的mark word 其内部的 lock word 会指向获取锁线程的那个 lockRecord 地址，locakRecord 里面 owner 字段又存放了获取锁线程的标识, 标识该锁被该线程所占用 **。

  * 否则说明存在两个以上的锁抢锁，首先会自旋获取锁

    * `cas` 获取锁是指线程一致循环尝试，当观察到锁对象为`无锁状态`才会发起`cas` 替换操作，将对象头中存放mark word的内容位置替换指向当前线程 **DisplacedMarkWord** 地址，并且更新`owner`字段。
    * 那么如果自旋时间到了？ **若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态**。 

### 轻量级锁升级的撤销(升级)

  * 轻量级锁到重量级锁的过程，上面已讲，就是出现了两个以上线程的竞争。
  * 关于轻量级锁的释放如下:
  * 假设A线程为持有锁，那么需要将A线程栈中的`lock record`替换掉锁对象对象头的存储的指向当前线程**DisplacedMarkWord**  的地址。
  * 如果替换失败（说明这个时候锁对象已经被其他线程升级为重量级锁了，升级为重量锁之后，存的就不是那个地址，而是锁对象信号量的地址了），说明存在另外的线程抢锁失败自动挂起，需要在释放锁的同时，唤醒其他线程。
  * **关于重量级锁 其实就是monitor 的一些操作**
  * ![1569808417748](C:\Users\d00464537\AppData\Roaming\Typora\typora-user-images\1569808417748.png)
* 对应重量级锁而言，所有新加入的线程都会处于 左边的EntrySet 集合里面，所有进入到同步块之后调用了对象的wait 方法的线程便回到右边的WaitSet 区域等待被唤醒，与左边的一起竞争，不分优先级。
* 详细资料参考[死磕并发](<https://juejin.im/post/5b4eec7df265da0fa00a118f>) 、[others](<https://www.cnblogs.com/paddix/p/5405678.html>)  ,这两篇文章讲的非常细致了，看了好几个小时呢。

####  reentrantLock 锁

* 内部维护了一个双向无循环链表（称为同步队列），非公平锁，每次一来便先抢占锁，没抢成功则进行后续的自旋入队的操作（这里是将自身线程封装成一个子节点node），添加至队列尾部，并根据一些判断将自身挂起，一直等到他的前节点来将它唤醒。拿锁的条件是（当前节点是头结点的后续节点，并且当前节点cas 操作成功）
* 关于这个锁还有一重条件锁机制（ConditionObject）,一个了lock 可以关联多把ConditionObject机制，通过await/singal 来实现 wait/notify 的语义。

#### 两种锁的比较

* 使用层面
  1. syn 只支持非公平锁，syn 阻塞状态不支持中断。
  2. lock 支持可中断锁，和公平锁。除此之外lock 还可以实现独占锁，和共享锁。
  3. 二者都是可重入的。
* 原理层面
  1. syn 是基于操作系统级别的互斥指令来实现的，对应同步代码块而言是通过monitorenter,和monitorexit，对应方法同步来说是在方法调用指令的时候检查是否含有关键字，如果含有的话则需要先获取对象锁。
  2. lock 是内部基于AQS 同步器来实现获取锁操作的，AQS 内部又是基于CAS 自旋锁来实现的。

