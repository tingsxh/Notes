### 锁的笔记

#### synchronized

* synchronized，四种状态的转换
* 关于synchronized 的两个要点需要明白：`对象头` 以及`monitor`管程，每个对象都生来具有一把隐形锁，就是`monitor` 监视器。

##### 使用

* 在处理同步代码块，同步方法的时候，在字节码层面是不太一样的

```java
// 三个不同的同步方法  
public void test1(String name) {
        synchronized (this) {
            System.out.println("123");
        }
    }
    public synchronized void test2(String name) {
        System.out.println("456");
    }

    public static synchronized void test3(String name) {
        System.out.println("456");
    }
```

```shell
 public void test1(java.lang.String);
         3: monitorenter
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #3                  // String 123
         9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: aload_2
        13: monitorexit
        19: monitorexit
        22: return
  public synchronized void test2(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    //
  public static synchronized void test3(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
```

* 对于同步代码块来说是采用monitorenter，monitorexit 这两条指令来实现方法同步的。但是对于方法的同步来说是通过在方法的ACC_SYNCHRONIZED 标志来实现同步的，如果设置了该标志位，执行线程将先获取monitor 获取成功之后才能执行方法。**获取锁都是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度**
* 对象的具体结构在这里不是重点（markWord 里面存放了对象的hashCode,锁的标志位，对象的分代年龄）
* 在当前jdk8 里面`synchronized` 的前面几种锁状态都是依赖于锁对象头里面的`Mark Word`（标记字段） ，来进行`cas` 操作拿锁的，即使逐步膨胀为重量级锁也依赖于锁对象头里面的 `mark word` 字段来标记了，既然这个`mark word` 这么重要，那就有必要知道它到底是个啥东西了，如下：
* ![1569821826371](C:\Users\d00464537\AppData\Roaming\Typora\typora-user-images\1569821826371.png)

  * 当前锁对象是否处于偏向，是由`是否偏向` 那个标志为控制的, `锁的标志`则用来判断锁当前处于何种级别的锁状态中。
* 至于偏向锁是什么东西，简而言之就是（**我第一次获取了锁，我下次就不去获取锁了，直接判断下拿锁的人是不是我就好了，如果不是，我再尝试拿一次，拿不到我就升级**）
* 锁的状态码

| 锁状态   | 存储内容                                                | 存储内容 |
| :------- | :------------------------------------------------------ | :------- |
| 无锁     | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01       |
| 偏向锁   | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01       |
| 轻量级锁 | 指向栈中锁记录的指针                                    | 00       |
| 重量级锁 | 指向互斥量（重量级锁）的指针                            | 10       |

### 无锁到偏向锁

  * 偏向锁是针对于单线程运行情况下做的优化，在目前的jdk版本中，对象锁默认都是开启了可偏向状态的，线程第一次获取偏向锁的过程如下：

    * 首先判断对象是否为可偏向状态 即 锁的状态为**01**无锁状态以及是可偏向状态（标志位为1），

    * 如果是可偏向状态：

      * 那么就直接cas 操作将对象头MarkWord 中存储线程id 的位置替换为当前线程A。
      * 如果成功：
        * 说明已经成功获取偏向锁了，继续执行同步代码块。
      * 如果失败：
        * 说明此时已经有另外一个线程B 获取了锁,此时线程A应该是将锁对象升级为轻量级锁(就是偏向锁的撤销)。

    * 如果是已经偏向的状态：

      那么则需要检查锁对象头里面的线程id 是否和当前线程A一致。

      * 如果相等：则说明已经拥有偏向锁，直接执行同步代码即可
      * 如果不相等：则说明需要存在竞争，需要尝试重新偏向，或者偏向锁升级。

    * 如果是不可偏向状态，那么就直接以轻量级锁的方式来获取。

### 偏向锁的撤销 (升级)

  * 偏向锁的撤销是由尝试拿锁的另外一个线程B来触发的，撤销过程需要等到全局安全点上来执行。

  * 如上所诉，出现偏向锁撤销有两种情况(1.第一次抢锁失败，2.测试偏向锁是否偏向自身失败时)

  * 撤销分如下几步：

    1.先根据锁对象中记录的已经获取了锁的线程id,判断该线程是否还存活

    * 如果已经销毁：则直接将锁状态恢复为无锁状态且可偏向的状态（这样线程B 就可以以获取偏向锁的方式获取）
    * 如果线程依旧存活：1.则需要根据线程id找到相应的线程执行栈，再判断线程是后还持有该锁对象、
      * 如果继续持有，则需要将锁对象升级为轻量级锁，随便补齐轻量级锁需要的MarkWord指针重定向等等步骤。(这里的操作是将锁对象头中的存储的线程ID 信息替换为当前线程的锁记录地址)
      * 如果不再持有，则可以将锁恢复至（不可偏向的无锁状态，因为偏向锁过期了，等下一线程重新获取锁)。

    **锁升级的过程，等到GC达安全点的时候（将持有锁的线程挂起，并且修改锁的标识位为轻量级锁，状态码00），还有就是修改`mark word `指向 持有锁线程 线程栈中的`lock record`（锁记录）**，升级为轻量级锁之后，自身再加入`cas` 轻量级锁的竞争当中。

### 偏向锁到轻量级锁

* cas 轻量级锁自旋拿锁的过程

* 线程1获取轻量级锁时会先把锁对象的**对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间**（称为DisplacedMarkWord），然后**使用CAS把对象头中的内容替换为线程1存储的锁记录（**DisplacedMarkWord**）的地址**； 

* 如果替换成功了，这才算是成功获取锁咯，再进一步把MarkWord中的锁标记设置为`00` 表示处于轻量级锁定状态。

* 如果替换失败了，再进一步检查当前对象头是否指向当前线程的MarkWord,如果是，则重入锁。因为**对应轻量级锁, 线程首先会创建一个lock Record 的线程栈，用于存储mark word 的拷贝，每一个被加锁的mark word 其内部的 lock word 会指向获取锁线程的那个 lockRecord 地址，locakRecord 里面 owner 字段又存放了获取锁线程的标识, 标识该锁被该线程所占用 **。

* 否则说明存在两个以上的锁抢锁，首先会自旋获取锁

  * `cas` 获取锁是指线程一致循环尝试，当观察到锁对象为**无锁状态**才会发起`cas` 替换操作，将对象头中存放mark word的内容位置替换指向当前线程 **DisplacedMarkWord** 地址，并且更新`owner`字段。
  * 那么如果自旋时间到了？ **若自旋结束时仍未获得锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，当前线程以及后面等待锁的线程也要进入阻塞状态**。 

### 轻量级锁升级的撤销(升级)

  * 轻量级锁到重量级锁的过程，上面已讲，就是出现了两个以上线程的竞争。
  * 关于轻量级锁的释放如下:
  * 假设A线程为持有锁，那么需要将A线程栈中的`lock record`替换掉锁对象对象头的存储的指向当前线程**DisplacedMarkWord**  的地址。
  * 如果替换失败（说明这个时候锁对象已经被其他线程升级为重量级锁了，升级为重量锁之后，存的就不是那个地址，而是锁对象信号量的地址了），说明存在另外的线程抢锁失败自动挂起，需要在释放锁的同时，唤醒其他线程。
  * **关于重量级锁 其实就是monitor 的一些操作**
  * ![1569808417748](C:\Users\d00464537\AppData\Roaming\Typora\typora-user-images\1569808417748.png)
* 对应重量级锁而言，所有新加入的线程都会处于 左边的EntrySet 集合里面，所有进入到同步块之后调用了对象的wait 方法的线程便回到右边的WaitSet 区域等待被唤醒，与左边的一起竞争，不分优先级。
* 详细资料参考[死磕并发](<https://juejin.im/post/5b4eec7df265da0fa00a118f>) 、[others](<https://www.cnblogs.com/paddix/p/5405678.html>)  ,这两篇文章讲的非常细致了，看了好几个小时呢。

###　流程总结

1. 偏向锁时，锁对象头的标志位为01，以及是否偏向，如果是偏向状态那么再检查锁对象头中的线程Id 是否是自身，如果是的话则直接拿锁，如果不是的话则进行cas 拿锁操作(**这里的拿锁条件是，无锁状态且为非偏向，才可以替换线程id**)。
2. 如果CAS替换失败了，需要进一步 挂起之前持有锁的线程，然后再检查原来线程是否还继续保持偏向锁，如果没有保持了，那么将锁标志位改为 无锁状态,且非偏向标志，继续尝试获取锁，如果原来的线程继续持有锁，那么就需要进行锁升级了。（这一步也就是偏向锁的撤销）
3. 锁升级的第一步是需要先将持有偏向锁的线程挂起，为其设置好想要的锁记录(lock record)，设置锁记录其实是将锁对象的MarkWord 复制到线程的锁记录位置，然后将锁对象的MarkWord 指针指向当前线程的锁记录。然后自身线程再继续加入竞争轻量级锁的程序里。
4. 轻量级锁的自选过程，一方面是判断当前锁对象有没有释放，一方面是尝试替换锁对象中mark word 的指针指向当前线程的锁记录

####  reentrantLock 锁

* 内部维护了一个双向无循环链表（称为同步队列），非公平锁，每次一来便先抢占锁，没抢成功则进行后续的自旋入队的操作（这里是将自身线程封装成一个子节点node），添加至队列尾部，并根据一些判断将自身挂起，一直等到他的前节点来将它唤醒。拿锁的条件是（当前节点是头结点的后续节点，并且当前节点cas 操作成功）
* 关于这个锁还有一重条件锁机制（ConditionObject）,一个了lock 可以关联多把ConditionObject机制，通过await/singal 来实现 wait/notify 的语义。

#### 两种锁的比较

* 使用层面
  1. syn 只支持非公平锁，syn 阻塞状态不支持中断。
  2. lock 支持可中断锁，和公平锁。除此之外lock 还可以实现独占锁，和共享锁（也就是读写锁）
  3. 二者都是可重入的。
* 原理层面
  1. syn 是基于操作系统级别的互斥指令来实现的，对应同步代码块而言是通过monitorenter,和monitorexit，对应方法同步来说是在方法调用指令的时候检查是否含有关键字，如果含有的话则需要先获取对象锁。
  2. lock 是内部基于AQS 同步器来实现获取锁操作的，AQS 内部又是基于CAS 自旋锁来实现的。

### CAS

* CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：

* ABA问题,CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。

* JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。

* **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

* 只能保证一个共享变量的原子操作

  对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。

  Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

[参考资料](https://www.zhihu.com/question/53826114)
