## Innodb 中锁的细节

### 锁的分类

* Lock锁

  lock 里面可以再细分为行级索，表锁，页锁之类的，其中行锁分为共享锁（S锁），排他锁（X排他锁）

* 意向锁，将锁定的对象分为多个层次，在更细粒度上进行加锁，意向锁中分为IS(意向共享锁)，IX(意向排他锁)

* 自增长锁

  在innodb 中自增长

#### 锁的算法

* Record Lock (行记录锁)，总是会锁住索引记录，如果InnoDB 存储引擎表在建立的时候没有索引，则会使用主键来锁定
* Gap Lock (间隙锁)，锁定一个范围不包含本身
* Next-Key Lock (行锁+间隙锁)
* 在innodb 中可重复读的隔离级别下，默认的查询中都是使用这种方法，以避免幻读的问题。但是当查询的条件是主键且唯一的情况下，就会降级为Record Lock 。

```shell
# 对于表存在 10,11,13,20 这四个值，那么锁定的区间将分为 (~,10] (10,11] (11,13] (13,20]
# 对于 1,3,6,8 这 四个索引值，如果select xxx=3 for update  的话 则会锁定 (1,3) (3,6), 插入1会阻塞，插入0，和6 不会阻塞。
```

#### 幻读

#### 什么是幻读？

* 幻读是在`可重复读`的事务隔离级别下会出现的一种问题，简单来说，`可重复读`保证了当前事务不会读取到其他事务已提交的 `UPDATE` 操作。但同时，也会导致当  前事务无法感知到来自其他事务中的 `INSERT` 或 `DELETE` 操作，这就是`幻读`。

```shell
# 比如在同一个事务A中查询，select * from t where a>2 
# 如果这个时候存在其他事务也在插入a>2 的数据并且提交，那么对于事务A来说的话，前后读取的数据将会不一致。
```

* 解决幻读的方法，就是根据查询的条件加上相应的间隙锁。

#### 脏读

* 读取了未提交的数据。

#### 不可重复读

* 针对同一数据的读取，多次读取返回结果值不一样，通过并发版本控制

#### 更新丢失

