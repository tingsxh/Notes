[TOC]



## JVM 内存分布笔记

### 程序计数器

* 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因 此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

### 虚拟机栈

* 每一个方法的调用都会生成一个栈帧。其中包含**局部变量表，操作数栈，放回返回地址，动态链接**等等
* 虚拟机栈的内存主要来自于 jvm总内存- 最大堆内存 - 最大方法区内存 剩下的内存由各个线程瓜分。

#### 栈桢内存溢出

* 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
* 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常（**hotSpot 虚拟机不支持动态扩展**）。

* 实验结果表明：无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。
* 当在方法内部不断新建线程的话，那么就会抛出OOM 异常

### 方法区

* 主要存放，class文件加载之后的类信息，以及常量池等信息，（有些资料也称之为永久带，但是到了jdk8 之后就统一称之为元空间）。

#### 运行时常量池（方法区的一部分）

* 这点与calss文件编译完成后的结构中的常量池不一致。字节码文件中的**常量池表**在加载这一阶段的时候，会存入运行时常量池当中。但是运行时常量池还有个动态的特性，在运行期间也可以生成新的常量值存放于此。例如string.intern()
* 运行时常量池也是属于方法区的一部分。里面主要存放字面量以及符号引用。

#### intern() 使用的注意

* 在jdk6 之前 String.intern() 方法是判断运行时常量池中是否存在该字符串，如果存在则直接返回，如果不存在则复制一份当前值，存放至常量池，再返回相应的引用。存放在这里会引起常量池溢出

  就是把首次遇到的实例对象复制到方法区常量池当中。

* 在jdk7的时候，String.intern() 则是会记录首次出现该值的一个引用，该字符串的存放位置已经由方法区的常量池移动到了java 堆上了。

#### 方法区内存溢出

* 方法区也会存在溢出的问题，如运行的过程中产生了大量的动态代理类信息

#### 常量池内存溢出

* 在jdk6 之前 常量池也会出现内存溢出，主要是因为常量都是保存在方法区内部的常量池中
* 但是到了jdk7之后，常量池的存放位置移动到了堆，所以方法区不会因为常量的增加而出现内存溢出了

### 堆

#### 堆上内存的划分

* 指针碰撞法：整个堆分为空闲和非空闲，中间有一个指针分界，每当需要划分新的内存时，只需要将指针向相应的空闲侧移动即可。典型的有Serial 垃圾收集器。
* 空闲列法：java堆上的可用空间时不完整的，空闲与非空闲交错，这种情况下就需要用一个列表来记录每一块内存的使用情况。典型有 Cms垃圾收集器。
* 使用合作方法分配取决于堆内存的完整性，完整性又取决于垃圾收集器的选择
* 内存空间的分配还需要考虑到线程安全问题。

#### 堆上的内存溢出

* 

### 对象

#### 对象的创建

* 当虚拟机遇到解析到一个new 指令的时候，首先会检查在常量池中是否能找到该类的符号引用，然后执行加载->连接->和初始化等步骤

* 然后需要在堆上化出一块足够大小的空间。
* 对于如何保证线程安全的分配堆上的内存，可用使用CAS失败重试来保证内存更新的原子性，还有一个方案是按照不同的线程，提前分配缓存区，哪个线程要分配内存就在哪个线程的本地缓冲区中分配，只有本地缓冲区使用完了才需要加锁来来分配新的内存。
* 在 new 指令之后将会执行<init> 方法，完成实例的初始化操作。

#### 对象内存的布局

* 对象在内存中 布局可概括为三部分（对象头，实例数据，对齐填充）：

* 对象头：

  对象头又可以细分为如下：

  * 运行时数据：

    包括哈希码，GC分代年龄，锁标志位，线程持有锁，偏向锁信息等等。

  * 类型指针：

    就是指向该对象的类的元数据信息，通过这个指针确定该对象时哪个类的实例。

  * 数组长度（如果对象是数组的话）

    还有一部分，如果对象时数组对象的话，对象头里面爱存放着数组的长度。

* 实例数据：

  就是代码中所定义的字段信息，包括从父类中继承下来的。

* 对齐填充

  由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。

  换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者 2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。（**会浪费内存空间**）

#### 对象的访问

* 对象创建完成之后的使用，我们往往是通过虚拟机栈上的refrence引用来操作堆上的对象。目前也有两种访问方式（分别是使用句柄和直接指针两种）

* 句柄式

  refrence 存储的是堆上句柄的地址，句柄内部在指向具体的实例地址，这种方式更加稳定，当实例地址改变了之后，只需要改变句柄内的信息即可，不需要修改refrence 的值

* 直接指针式

  refrence 存储的直接就是实例的地址信息，这种方式访问更快，因为少了一次间接访问句柄的开销。
