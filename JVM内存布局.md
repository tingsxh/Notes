## JVM 内存分布笔记

### 虚拟机栈

* 每一个方法的调用都会生成一个栈帧。其中包含局部变量表，操作数栈，放回返回地址等等
* 虚拟机栈的内存主要来自于 jvm总内存- 最大堆内存 - 最大方法区内存 剩下的内存由各个线程瓜分。

### 方法区

* 主要存放，class文件加载之后的类信息，以及常量池等信息，（有些资料也称之为永久带）。

#### 运行时常量池

* 这点与calss文件编译完成后的结构中的常量池不一致。字节码文件中的常量池在加载这一阶段的时候，会存入运行时常量池当中。但是运行时常量池还有哥动态的特性，在运行期间也可以生成新的常量值存放于此。例如string.intern()
* 运行时常量池也是属于方法区的一部分。里面主要存放字面量以及符号引用。

#### intern() 使用的注意

* 在jdk6 之前 String.intern() 方法是判断运行时常量池中是否存在该字符串，如果存在则直接返回，如果不存在则复制一份当前值，存放至常量池，再返回相应的引用。
* 在jdk7的时候，String.intern() 则是会记录首次出现该值的一个引用，没有值的复制操作。后续直接返回这个引用即可。

### 堆

#### 堆上内存的划分

* 指针碰撞法：整个堆分为空闲和非空闲，中间有一个指针分界，每当需要划分新的内存时，只需要将指针向相应的空闲侧移动即可。典型的有Serial 垃圾收集器。
* 空闲列法：java堆上的可用空间时不完整的，空闲与非空闲交错，这种情况下就需要用一个列表来记录每一块内存的使用情况。典型有 Cms垃圾收集器。
* 使用合作方法分配取决于堆内存的完整性，完整性又取决于垃圾收集器的选择
* 内存空间的分配还需要考虑到线程安全问题。

#### 对象内存的布局

* 对象在内存中 布局可概括为三部分（对象头，实例数据，对齐填充）：

* 对象头：

  对象头又可以细分为如下：

  * 运行时数据：

    包括哈希码，GC分代年龄，锁标志位，线程持有锁，偏向锁信息等等。

  * 类型指针：

    就是指向该对象的类的元数据信息，通过这个指针确定该对象时哪个类的实例。

  * 数组长度

    还有一部分，如果对象时数组对象的话，对象头里面爱存放着数组的长度。

* 实例数据：

  就是代码中所定义的字段信息，包括从父类中继承下来的。

#### 对象的访问

* 对象创建完成之后的使用，我们往往是通过虚拟机栈上的refrence引用来操作堆上的对象。目前也有两种访问方式（分别是使用句柄和直接指针两种）