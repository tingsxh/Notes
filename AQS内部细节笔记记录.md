### AQS的内部结构记录

#### 关键数据结构

* AQS 内部有几个关键的数据结构，一个是同步队列，一个是条件队列。

#### 独占锁 ReentrantLock

##### 独占锁的获取流程（非公平）

* 整个AQS 独占锁获取其实就是对 AQS 内部变量STATE 的操作，如果STATE 是0 则代表无锁，为1 代表被锁定。

1. 首先通过CAS 抢占式获取锁，如果获取失败则进行一步操作
2. 再进行一次尝试获取，获取失败再判断当前持有锁的线程是否和自身一致，如果是则返回true.
3. 如果返回失败，则需要进一步将当前线程包装成一个Node 节点，加入到同步队列的尾部。
4. 队列加入到了尾部之后再进一步进入循环获取锁的过程，这一步主要是判断当前节点的前驱节点是否是头节点，如果是则尝试去竞争锁。
5. 如果竞争失败，这判断当前线程是否应该挂起，判断的条件是 如果当前线程的前置节点的 waitStatus=SIGNAL, 如果前置节点的waitStatus=CANCELLED，则需要移除前面的节点。直到当前节点的前置节点是SIGNAL，则将当前线程挂起，直到被其前置节点唤起或者自身中断。

##### 公平锁的获取

1. 对应公平锁而言在获取锁之前需要进行判断当前同步队列是否有其余节点，如果存在则直接进入同步队列尾部等待。
2. 如果不存在其他队列才尝试进行获取锁的操作。

##### 超时锁

1. 和非公平独占锁逻辑基本一致，只不过在循环处理的逻辑处，多了一个时间的判断，线程的挂起时间也是一定时间内的。

##### 锁的释放流程

* 释放流程主要分如下几步

1. 如果当前线程持有该锁的话，则将state 字段减一,当state==0 的时候 将锁释放。
2. 如果当前头节点不为空，则进一步唤醒后置节点，（这里的唤醒后置节点，采用的是从尾部向前遍历的顺序）

#### 共享锁 

* 共享锁的具体实现主要体现在读写锁内部。
