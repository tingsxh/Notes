### AQS的内部结构记录

### 同步器工作原理

#### 模板方法

`acquire`、`acquireInterruptibly`、`acquireNanos`、`acquireShared` 、`release`、`releaseShared`

#### 子类可重写的方法

`tryAcquire`、`tryRelease` 、`tryAcquireShared`、`tryReleaseShared`

#### 关键数据结构

* AQS 内部有几个关键的数据结构，一个是同步队列，一个是条件队列。

#### 实现方式

* 通常来说都是在子类内部实现一个继承自AQS 的内部类，重写其中的方法，使用的时候只需要调用AQS 提供的模板方法。这样一来用户不需要关注入队以及出队等一系列的操作。

### 核心组件

#### 同步队列

* 当前线程获取 同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其
  加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再
  次尝试获取同步状态。
* 在Node 结构当中，`nextWaiter` 和节点类型标志位是共享一个字段的。

#### 独占锁 ReentrantLock

##### 独占锁的获取流程（非公平）

##### 公平锁的获取

1. 对应公平锁而言在获取锁之前需要进行判断当前同步队列是否有其余节点，如果存在则直接进入同步队列尾部等待。
2. 如果不存在其他队列才尝试进行获取锁的操作。

##### 超时锁

1. 和非公平独占锁逻辑基本一致，只不过在循环处理的逻辑处，多了一个时间的判断，线程的挂起时间也是一定时间内的。

##### 锁的释放流程

* 释放流程主要分如下几步

1. 如果当前线程持有该锁的话，则将state 字段减一,当state==0 的时候 将锁释放。
2. 如果当前头节点不为空，则进一步唤醒后置节点，（这里的唤醒后置节点，采用的是从尾部向前遍历的顺序）

#### 共享锁 

* 共享锁的获取依靠判断 tryAcquireShared 方法返回值的大小来做判断，返回值大于等于0 表示成功获取共享锁

* 共享锁的具体实现主要体现在读写锁内部。
