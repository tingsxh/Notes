## 并发相关复习

### JUC 相关

* ReentrantLock

  * 可重入锁，可中断

  * 非公平与公平的实现

  * 以及锁的同步队列，锁的释放 

* CountDownLatch

* 当指定线程数 都执行了减一操作时，唤醒处于awit 的线程

* CyclicBarrier
  当指定个数的线程达到wait 状态时，触发执行某个操作，然后唤醒所有阻塞的线程、

* ConditionObject
  对于同一把锁，不同线程之间的通信，优势在于可以控制多个条件变量，例如可以用来做生产者消费者模式

* Semaphore 信号量

  * private static final Semaphore SEMAPHORE = new Semaphore(1);
  * 原子性操作，可以用来拿锁，或者用来对连接池 做限流控制
  * 通过其 acquire() 以及 release() 方法来获取锁以及释放锁
  * 示例用于流量控制，控制同时能用多少个线程执行

* exchanger 线程间数据交换

  * ```java
    Integer s = exchanger.exchange(30);
    ```

* ForkJoin

  * 

* PriorityBlockingQueue

  * 具有优先级特性的队列
  * 内部基于二叉堆工作(二叉堆， 数据分布 a[n] 的左子节点为a[2*n+1] a[n] 的右子节点为a[2*n+2])
  * 二叉堆插入方式，首先判断插入的是左节点还是右节点（其父节点肯定是(n-1)/2 ）继续比较与父节点的大小，如果比父节点大则满足最小堆规则，如果比父节点大，则位置与父节点位置互换，插入位置也换成父节点伪位置，继续判断。                       

* LinkedBlockingQueue,ArrayBlockingQueue
  * LinkedBlockingQueue 和ArrayBlockingQueue 在实现阻塞时时不同的，linkedBlocking 时基于两个不同的Lock 来做的，Arrary 是基于一个lock 来做的,至于为什么？
  * 这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。
* linkedBlockingQueue 可以实现生产者消费者问题
  
* BlockQueue 具有 put 操作，如果队列已满则会自动阻塞

  ```java
  // 插入相关操作
  add(e) 如果已经满了则抛出异常;
  offer(e) 如果已经满了则返回null;
  put(e) 只有blockQueue 才具备的，当队列已经满了，会一直阻塞;
  //去除相关操作
  remove()
  poll()
  task() 如果为空将会阻塞;
  
  ```

  

* CompletionService

  * 批量提交相应的异步任务，只要有一个执行完成就退出。

* 队列相关

  * 单端非阻塞、单端阻塞、双端非阻塞、双端阻塞。

* 读写锁相关

  * **还未深入了解**

### 线程池相关

* ```java
  ExecutorService pool = Executors.newFixedThreadPool(3);
  CompletionService service = new ExecutorCompletionService(pool);
  ```

* **threadLocal** 

  * 利用每个线程自带的一个属性(ThreadLocalMap), ThreadLocalMap 中又维护着一个Entry[] 的数组，一个Entry 由key,value 一个组成，key 则是一个ThreadLocal 对象，value 则是object,
  * 说明，一个线程加一个threadLocal 才能唯一确定一个值，一个线程可以保存多个value ,但每个value 都必须来自不同的threadLocal

### 锁相关

- **互斥**：共享资源X和共享资源Y只能被一个线程占用
- **占有且等待**：线程T1占有共享资源X，在等待共享资源Y的时候，不会释放共享资源X
- **不可抢占**：其他线程不能强行抢占线程已经占有的共享资源
- **循环等待**：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源

* 死锁(你依赖我，我赖你)，活锁（你等我，我等你），饥饿（优先级轮不上） 分别代表三种不同的block 状态
* 锁的几个 知识点：
  * 乐观锁，悲观锁，读写锁，分段锁

### 线程相关

* 线程生命周期的管理

生命周期 NEW--> RUNNABLE-->TERMINATED,当线程block 状态的时候，中断会重新唤起线程，并抛出中断异常

* 最佳线程数 = CPU核数 * [1 + (IO耗时 / CPU耗时)]

* 线程池提交任务的方法

```java
   public void execute(Runnable command) {
        if (command == null)
            //判空
            throw new NullPointerException();
       //获取当前线程数量
        int c = ctl.get();
       //如果小于核心线程数，尝试添加一个新的
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
             // 如果线程关闭了，并且从对了成功移除了
            if (! isRunning(recheck) && remove(command))
                //拒绝策略
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

