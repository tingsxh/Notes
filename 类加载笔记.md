

### 关于常量池的疑惑

* 常量池中存放字面量以及符号引用
* 常量值的定义？初始化情况？
  * 对于类级别的static 常量来说，其被初始化的地方有两种可能，一个是在类的构造器（这里不同于实例构造方法），对于被修饰为（final static） 的基本数据类型或者字符串来说，初始化的地方是在编译的时候利用costantValue属性来实现的
* static 和final static 的初始化对比？

### 类加载的时间

* 只有当遇到如下几种情况的时候，才一定会触发类的初始化操作，也就意味着(在此之前 类的加载以及验证，准备阶段都得完成，解析阶段不一定)
  1. 直接调用new 关键字创建对象，或者调用static 的类成员变量，或者静态方法
  2. 使用反射相关调用
  3. 初始化一个类时，需要保证其父类进行过初始化（接口不需要这个要求）
  4. 用户程序所指定的main 主类
* 值得注意的是，final 修饰的常量在编译期间会存放在调用方的类常量池中。

### 类的加载机制

#### 分为 加载阶段---> 连接阶段（验证，准备，解析）---->类初始化阶段

* 加载阶段：加载阶段主要完成（数组类型除外，数组类型是有JVM 虚拟机创建的）

  * 将class文件或者压缩包文件，转换成一种二级制字节流的格式
  * 将二级制字节流转换为方法区内存储的运行时数据结构，存储在ＪＶＭ内部方法区内部
  * 生产一个 class 对象，存放在方法区，作为该类对外提供功能的统一入口

* 对于数组对象的加载有些不同：数组对象本身是有java虚拟机直接创建的，但是对于数组类的元类型，还是需要类加载加载。如果元类型是基本数据类型 如`int[]` 的话，则对象还是会与引导类加载器关联，如果是引用类型的话，则进行普通的类加载，通常是应用程序加载器来加载。

  **对于任何类的加载，都必须与一个类加载器相关联，才能确定一个唯一性**

* 验证阶段

* 之所以需要验证是因为可以通过不编译的方式产生字节码文件。

  * 验证class文件格式是否合法，
* 元数据验证。
  * 验证字节码是否合法
  * 验证符号引用等是否存在等等

* 准备阶段

  * 我理解就是给类变量赋初始值并且设置内存的阶段，注意这里的类变量是指 static 修修饰的，初始值的话统一为0 或者null,false 之类的，至于字段的实际值，则会在初始化阶段进行设置（这里被final 修饰的常量值除外，如果识别到具有constantValue 则直接赋相应的值给该变量）
  * 类变量的内存都是在方法区中进行分配的，而实例变量是在实例初始化被分配在堆上的。

* 解析阶段

  解析阶段就是做的将符号引用解析为直接引用的一个过程。

  * 符号引用，指的是能够准确无歧义的定位到目标的字符串，与内存布局无关，需要解析成直接引用才能访问到具体对象。
  * 直接引用，指的是可以直接执行目标对象内存的指针，活着相对偏移量。

  虚拟机中只规范了当遇到一系列操作`符号引用` 的字节码指令之前，需要先对这些将要使用到的符号引用进行解析。

  所以符号引用的解析，既可以发生在类加载时刻，也可以发生在运行时时期。

* 初始化阶段

  * 这个阶段我理解就是执行 clinit 方法（这个方法是编译器自动生成的）按照书写的顺序将类变量复制动作和静态语句块 组合成一个方法。这个初始化方法只会执行一次
  * 注意静态方法块，他可以给出现在其后的字段赋值，但是不可用引用

* 
