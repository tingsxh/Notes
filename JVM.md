[TOC]

## JVM 类加载机制

### 加载

* 类的加载器主要分为三大类 **启动类加载器(JVM 自带，由C++实现)、启动类加载器、应用程序加载器**

* 类的加载分为 **加载，链接（准备，验证，解析），初始化**。这几个阶段并没有完全的顺序关系，例如解析阶段可能会发生在 初始化阶段之后再进行（那么解析阶段到底是做什么事情呢？下面记录）。

#### 类的主动使用

* 而类的加载并没有规定具体执行的时间，但是 加载，准备，验证这几个阶段肯定是需要放在 初始化阶段之前的。那什么时候会触发一个类的初始化阶段呢？这个JVM规定了5种情况，分别是如下
  * 使用new 新建一个对象，或者调用一个类的静态方法，或者设置或获取一个类的静态字段
  * 使用反射创建对象的时候
  * 当初始化一个类发现其父类还未初始化的时候，会优先触发其父类的初始化(这里需要注意，对于接口而言，并不成立)
  * 虚拟机启动时会指定一个包含main 方法的类，虚拟机会首先初始化这个类。

#### 类的被动使用

* 以上记录的四种情况，称之为对类的主动使用，这些都是会触发类的初始化的。当然除此之外还有就是类的被动使用。
  * 通过子类访问父类的静态属性(包括字段和方法)的时候，是不会触发子类的初始化的。
  * 还有就是访问一个类的静态常量值的时候，会在编译期通过优化将常量存放在调用方的常量池中。
  * 还有就是数组类型初始化的时候。

#### 数组类的加载

* 对于类的加载阶段，可以分两种情况来讨论：一个是普通class类的加载，还有一类是数组类型的加载，如int[] 数组类并不是有类加载器实现加载的，而是有虚拟机直接进行加载的，在对数组类的加载过程中，jvm做了如下几个规定
  * 首先每个被加载的类，都必须要与一个类加载器相关联以确保唯一性(换句话说，就是一个类其实是可以被不同加载器重复加载多次的)。
    * 但jvm在处理 数组类加载但过程中会有如下判断，首先是判断数组的组件类型(就是数组去除一个维度之后的数据类型) 是否是引用类型，例如A[] 的组件类型为A 。如果是的话那么A将由正常的类加载去加载，并且A[] 数组将和该加载相关联。当然这里需要注意一下，如果是多维数组，其对外表现上还是一个一维数组，只不过里面的内容还是一个数组类型而已，对于多维数组的加载，将会递归上述的加载方法。`A[][]-->A[]-->A` 这样一个步骤。
    * 如果不是的话，例如 int[] ，则将该数组与启动类加载器关联绑定。

### 验证

#### 文件格式的校验

* 字节码的魔数是否正确，版本号是否在该jvm版本允许范围内
* 常量池中是否含有非法字符引用

#### 元数据的验证

* 类的继承情况是否正常，是否都含有父类
* 是否重载非法，例如参数一直，但返回类型不一致。
* 检查java语义是否正确。

#### 字节码的验证

* 这里的校验非常复杂，例如校验跳转是否合法等等。
* 为了提升字节码校验的效率，Code属性表中增加了一项`StackMapTable` 属性，用于方法体中，开始时本地变量表和操作数栈的状态，这样就不用去遍历整个方法体来检查了。

#### 最后还有一个符号引用的验证

* 这个校验发生在解析阶段，主要是判断符合引用是否能找到响应的类信息
* 需要注意的是，验证阶段并非必须的，可以使用启动参数屏蔽该操作

### 准备

* 准备阶段只是给类变量赋上初始值，类变量指的是被`static`修饰的字段，例如int 类型的初始默认值是0。
* 但是有一种情况除外，如果在类字段的属性表中国存在`ConstantValue` 表示常量的时候，那么该字段则会在准备阶段直接赋予所设置的值，也即是`ConstanValue`所指定的值。

### 解析

* 解析过程主要的工作就是将符号引用替换为直接引用，那么这里需要理解下这两个概念：
  * 符号引用：
  * 直接引用：简单说来就是可以直接执行目标的指针，比如存储在堆中类，字段
* 解析主要分为 类和接口的解析以及字段的解析，类和接口中的方法的解析

### 初始化

* 初始化的过程主要是执行一个`<clinit>` 方法，这个方法是由虚拟机自动生成的，生成的规则是按照书写的前后顺序，将静态字段，静态代码块放在这个初始化方法中。
* 需要注意的是，在静态代码块中只能使用在它之前定义的静态字段，但是可以给它后面定义的字段进行赋值操作。
* 关于继承关系下这个方法的执行特性，对类而言，子类的初始化一定会触发父类的初始化方法，并且不需要显示调用。对于接口之间，不存在这种关系，在上面的加载过程一件强调过这层关系了。
* 但这个初始化方法却并不是必须的，如果不存在静态字段或代码块，则完全可以不生成。

### 双亲委派

* jvm虚拟机的类加载机制是使用双亲委派的机制来实现的，简单介绍就是，每一个类加载器(自定义的或者是系统自带的) 接收到一个类加载到请求，首先需要交给它的父类去加载，父类也依次类推，如果最顶层父类(启动类加载器)可以加载则由启动类加载器加载，否则的话就逐次降级到次父类加载器，直到交给自身来加载为止。
* 双亲委派到好处在于，维护了jvm系统类能够不被破坏。例如程序员自定义的与系统类重名的java.lang.Object 是无效的，不会被系统所加载。

* 双亲委派也是会被破坏的。