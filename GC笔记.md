## GC 笔记



### 判断对象存活

#### 引用计数法

* 存在互相引用无法被回收的问题

#### 可达性分析

* 顺着GC 根节点从下找，通过判断是否可达来判断对象是否应该被回收。
* 常见的GC 根节点有：
* 线程执行栈帧中局部变量表中的对象引用。
* 方法区中的静态变量引用。
* 方法区中常量的引用。

### 垃圾回收动作的发起

* 发起垃圾回收的第一步肯是需要先列举所有的GC 根节点，就是找到所有的常量，类的静态变量，以及线程栈帧中的对象引用。
* 为了列举更加快速，JVM 使用了OopMap 的数据结构记录了那些内存位置存放了什么类型的数据给记录下来了，所有JVM 只需要按照OopMap 的记录去遍历就可以很快找到GC 的根节点。
* 列举GC 根节点必须要全局暂停，否则没法准确的计算出相互之间的引用关系。

#### 安全点

* 当JVM 各线程 收到GC 停顿的通知之后，只有运行到了安全点之后才允许自身停下来。每个线程当运行到安全点时，只要发现GC 标记标记为是时，便将自身挂起。

#### 安全区域

* 安全区域其实就是安全点的扩展，针对一些处于sleep 或者Blocked 状态的线程，代表这一片区域内都不会发生对象引用关系变化。

### 垃圾回收算法

#### 标记清除算法

* 效率不高，容易产生内存碎片。

#### 复制回收算法

* 将内存一分为2，每次只使用其中一半，回收时将存活对象移动至另一半，再把剩余的一半全部回收掉。
* 例如新生代内存的回收就是使用这种方法进行的。将整个新生代划分为eden 和survivor 区域，整体比例在8:1:1 这里的sur区域还细分为 from区域和to 区域。

#### 标记整理算法

* 适用于老年代垃圾回收的一种回收机制。
* 和标记清除算法类似，只是在标记完成之后会将所有存活的对象都移动到一端，然后将存活对象边界以外的内存全部清理即可。

#### 分代收集

* 不同内存区域使用不同的收集算法来进行收集，存活率低的使用复制回收来收集，存活率高的使用标记整理算法来收集

### 新生代垃圾收集器

#### Serial 收集器

* 最早出现的收集器，单线程执行，主要工作于 Client 模式下新生代的垃圾收集，采用的时复制收集算法。

#### ParNew 收集器

* ParNew 收集器时Serial 的多线程版本，收集算法和上述一致，目前只有它和Serial 收集器可以搭配 CMS 老年大收集器一起工作

#### Parallel Scavenge 收集器

* 同样也是新生代垃圾收集器，它关注的重点在于如何控制程序的吞吐量 == 代码运行时间/(运行时间+垃圾收集时间)
* 该收集器 可以使用 -XX:+UseAdaptiveSizePolicy  是的虚拟机可以自动调整GC 参数。
* 无法与CMS 收集器搭配使用

### 老年代垃圾收集器

#### Serial Old 收集器

* serialOld 时serial收集器的老年代版本。

#### Parallel Old 收集器

* 它时Parallel Scavenge 的老年代版本。在注重吞吐量的server 模式下的应用程序可以选择 PS + PO 的组合

#### CMS 垃圾收集器

* 可以做到GC 线程与用户线程并发执行。

* 注重GC 的停顿时间的优化，可以获得高速的响应，收集算法使用的时 标记--清除。
* 大体分为如下四个步骤
* 初始标记
  * 该阶段主要标记 GC root可以直达的老年代对象
  * 以及新生代中引用的老年代对象
  * 这个过程需要暂停线程，并且会扫描整个新生代

* 并发标记
  * 该阶段主要就是依赖于上一阶段已经标记好的对象，进行进一步可达性分析，标记出所有可达到的对象，注意这个过程是和用户线程并发执行的，这就意味着，有些老年代的引用可能会出现变化（比如又有新生代对象引用了老年代对象，GC root 之前可直达，现在不可直达了）
* 重新标记
  * 正因为上述提到，并发标记阶段部分老年代对象的引用会出现变动，所以才有了一个重新标记阶段，就是针对在 并发标记过程中因程序运行导致标记记录发生变动的那一部分（需要暂停全部线程）
* 并发清除

##### CMS 收集器的缺点

* 因为时并发收集，所有必然会受到CPU的影响，CMS 默认开启的回收线程数时(CPU+3)/4。
* CMS 收集会产生浮动垃圾，因为在垃圾收集的过程中，用户线程还在运行，也会继续产生垃圾对象，而这部分垃圾只能留在下一次GC 来进行收集。也正因为用户线程的运行，所以在垃圾收集的时候还需要留一部分内存供其使用。
* 还有就是标记--清理方法带来的内存碎片的问题，不过每次在发生一次FullGC 之后进行一次内存整理。

#### G1 收集器

* G1 内存空间被划分为了多个大小相等的独立区域(Region), 虽然也分为年轻代和老年代，但是它们在物理空间上已经不是隔离的了。
* G1收集器可以单独完成整个堆空间的垃圾回收，根据每个region 的回收价值排序，优先回收价值最大的。
* 使用的标记--整理的收集算法来实现收集器，从局部上来看时基于复制算法实现的，不会产生内存碎片。
* 可预测的停顿时间

#### 如何避免全堆扫描

* 在新生代垃圾回收的时候，如何确定对象A 是否被老年代的对象所引用了，这可能会需要全堆去扫描。
* 在G1中也存在这个问题，如何确定在RegionA 中的对象是否被RegionB 区域中的对象所引用。
* JVM 采用了一种RememberSet 来避免全堆扫描（在对引用进行写入的时候，会产生中断，检查refrence 是否来自不同的region/ 新生代，如果是的话，会通过CardTable 在**被引用**的对象的RememberSet 中写入相关的引用信息），在GC 的时候，R-Set 也将最为GC-Root 。

### 堆上内存分配

#### 新生代分配

* 一般情况下是先分配在新生代的Eden 区域, 当然也存在特殊情况直接分配到老年代的情况。当Eden区域内存不足的时候变回触发一次MinorGc。

#### 老年代分配

* 因为新生代的可以区域是一个eden+Survivor (from) ，当发生minorGc 的时候，会将存活的对象移动至Survivor(to) 区域，如果survivor(to) 存放不下，则会通过分配担保机制进入老年代。

* 如果足够存放则GC 年龄加1，并且from 区域和to区域互换。

* 当然，对于大型对象也是有可能直接分配至老年代内存上的。

* 而对于在新生代中长期存活的对象**也就是反复在 from 和 to 区域之间来回复制的对象** ，当GC 年龄超过15次之后便可以进入老年代。

* 还有一种情况需要注意，就是当survivor 中相同年龄的所有对象的内存之后，大于survivor 总大小的一半之时也会提前进入老年代。


#### 内存担保

* 每次进行一次Minor Gc 之前都会检查当前老年代所剩余的空间是否大于当前新生代的全乎对象大小，如果大于的话那么说明这次Gc 是足够安全的。
* 如果不成立，则会查看是否允许担保失败，如果允许则进一步查看老年代的剩余空间是否大于历次从新生代移动至老年代对象大小的平均值，如果小于或者加入不允许担保失败，则需要触发一次FullGC。
* 再不济，在上述条件通过之后，最后进行分配还是失败了的话，依然会进行一次FullGc,这样也是最耗时的，因为连续来了两次 GC。

