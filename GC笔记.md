[TOC]

## GC 笔记



### 判断对象存活

#### 引用计数法

* 存在互相引用无法被回收的问题

#### 引用类型

* 强引用是最常见的，只要存在强引用便不会被回收
* 软引用，只有当即将内存溢出的时候会将这种类型的数据进行二次回收。
* 弱引用，只要开始垃圾回收，无论内存是否足够，都会将其回收。
* 虚引用

#### 可达性分析

* 顺着GC 根节点从下找，通过判断是否可达来判断对象是否应该被回收。

  **常见的GC 根节点有**：

* 线程执行栈帧中局部变量表中的对象引用。

* 方法区中的静态变量引用。

* 方法区中常量的引用。

* 所有被同步锁（synchronized关键字）持有的对象。

* 除了上面这些固定的GC-Root对象之外，还会有一些动态加入的GCRoot 区域。（例如解决跨代引用问题的**Remembered Set**）

### 垃圾回收动作的发起

* 发起垃圾回收的第一步肯是需要先列举所有的GC 根节点，就是找到所有的常量，类的静态变量，以及线程栈帧中的对象引用。

* 为了列举更加快速，JVM 使用了OopMap 的数据结构记录了那些内存位置存放了什么类型的数据给记录下来了，所有JVM 只需要按照OopMap 的记录去遍历就可以很快找到GC 的根节点。

  （**一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。**）

* 只有在安全点的位置才会记录OopMap 数据结构

* 因为JVM 在JIT 即时编译的时候，以及类加载的时候就可以明确知道类之间的引用关系。

* 列举GC 根节点必须要全局暂停，否则没法准确的计算出相互之间的引用关系。

#### 安全点

* 当JVM 各线程 收到GC 停顿的通知之后，只有运行到了安全点之后才允许自身停下来。每个线程当运行到安全点时，只要发现GC 标记标记为是时，便将自身挂起。
* ，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

#### 安全区域

* 安全区域其实就是安全点的扩展，针对一些处于sleep 或者Blocked 状态的线程，代表这一片区域内都不会发生对象引用关系变化。

### 垃圾回收算法

#### 标记清除算法

* 效率不高(因为回收算法随着回收对象的多少而变化)，容易产生内存碎片。使得后续大对象无法分配而提前触发一次FullGc。

#### 复制回收算法

* 将内存一分为2，每次只使用其中一半，回收时将存活对象移动至另一半，再把剩余的一半全部回收掉。
* 例如新生代内存的回收就是使用这种方法进行的。将整个新生代划分为eden 和survivor 区域，整体比例在8:1:1 这里的sur区域还细分为 from区域和to 区域。
* 浪费空间大

#### 标记整理算法

* 适用于老年代垃圾回收的一种回收机制。
* 和标记清除算法类似，只是在标记完成之后会将所有存活的对象都移动到一端，然后将存活对象边界以外的内存全部清理即可。

#### 分代收集

* 不同内存区域使用不同的收集算法来进行收集，存活率低的使用复制回收来收集，存活率高的使用标记整理算法来收集

#### 垃圾对象的逃脱

* 对象在被初次标记为垃圾对象之后会进行判断，是否需要执行`finalize`方法，如果需要的话便会执行异步一次，在这便可逃脱回收，但是一个对象只会被执行一次。

### 永久代代回收

* 永久代一般指的是方法区，也称之为元空间。可回收的对象只有废弃的常量以及废弃的类。判断废弃类的条件是
* 类不存在任何实例
* 加载该类的classLoder 已经被卸载了。

#### 如何避免全堆扫描

* 在新生代垃圾回收的时候，如何确定对象A 是否被老年代的对象所引用了，这可能会需要全堆去扫描。在G1中也存在这个问题，如何确定在RegionA 中的对象是否被RegionB 区域中的对象所引用。

#### 记忆集(RememberedSet)

* JVM 采用了一种RememberSet 来避免全堆扫描（在对引用进行写入的时候，会产生中断，检查refrence 是否来自不同的region/ 新生代，如果是的话，会通过CardTable 在**被引用**的对象的RememberSet 中写入相关的引用信息），在GC 的时候，R-Set 也将最为GC-Root 。
* **卡表** 是记忆集的一种实现。

#### 卡表的维护

* 理论上我们需要再对象被其他区域所引用，且在赋值的那一瞬间记录下卡表数据。但问题在于java 代码的执行可能是多种情况的，例如解释执行，和即使编译执行。在解释执行的时候，我们可以再处理字节码的时候介入，但是在编译执行的时候，所有的java 代码都变成了机器指令流了。
* 为了解决即使编译的问题，HotSpot 则是通过`写屏障` 技术维护卡表的状态。**写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切 面。**
* **怎么更新卡表引用记录？**

### 新生代垃圾收集器

#### Serial 收集器

* 最早出现的收集器，单线程执行，主要工作于 Client 模式下新生代的垃圾收集，采用的是复制收集算法。

#### ParNew 收集器（标记-复制）

* ParNew 收集器时Serial 的**多线程版本**，收集算法和上述一致，**目前只有它和Serial 收集器可以搭配 CMS 老年代收集器一起工作。**
* 自打jdk9 之后，parNew 就只能与CMS 合并使用，不可再单独设置使用了。

####　并发ＶＳ并行

* 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。
* 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于 垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响

#### Parallel Scavenge 收集器 （标记-复制）

* 同样也是新生代垃圾收集器，它关注的重点在于如何控制程序的 **吞吐量 == 代码运行时间/(运行时间+垃圾收集时间)**
* 该收集器 可以使用 -XX:+UseAdaptiveSizePolicy  使得虚拟机可以自动调整GC 参数，而无需手动指定参数了。
* 自适应策略也是区分上述收集器的一个重要特性。
* 无法与CMS 收集器搭配使用。

### 老年代垃圾收集器

#### Serial Old 收集器(标记整理)

* SerialOld 是 Serial收集器的老年代版本。其也是靠**单线程**来收集的

#### Parallel Old 收集器

* **多线程**收集

* 它时Parallel Scavenge 的老年代版本。在注重吞吐量的server 模式下的应用程序可以选择 PS + PO 的组合

#### CMS 垃圾收集器

* 可以做到GC 线程与用户线程并发执行。

* 注重GC 的停顿时间的优化，可以获得高速的响应，收集算法使用的时 **标记--清除**。

* 大体分为如下四个步骤

* 初始标记

  * 该阶段主要标记 GC root可以直达的老年代对象，并不需要一步步往下探测
  * 以及新生代中引用的老年代对象
  * 这个过程需要暂停线程，并且会扫描整个新生代

* 并发标记

  * 该阶段主要就是依赖于上一阶段已经标记好的对象，进行进一步可达性分析，标记出所有可达到的对象，注意这个过程是和用户线程并发执行的，这就意味着，有些老年代的引用可能会出现变化（比如又有新生代对象引用了老年代对象，GC root 之前可直达，现在不可直达了，或者之前不可直达，现在可以直达）

* 重新标记

  * 正因为上述提到，并发标记阶段部分老年代对象的引用会出现变动，所以才有了一个重新标记阶段，就是针对在 并发标记过程中因程序运行导致标记记录发生变动的那一部分（需要暂停全部线程）

* **重新标记是在干什么？**

  针对在并发标记过程中出现过引用变动的对象，以此为GCRoot 节点重新进行可达性分析。

  

* 并发清除

##### CMS 收集器的缺点

* 因为时并发收集，所有必然会受到CPU的影响，CMS 默认开启的回收线程数时(CPU+3)/4。CPU 数量越小受到的影响越大。
* CMS 收集会产生浮动垃圾，因为在垃圾收集的过程中，用户线程还在运行，也会继续产生垃圾对象，而这部分垃圾只能留在下一次GC 来进行收集。也正因为用户线程的运行，所以在垃圾收集的时候还需要留一部分内存供其使用。
* **如果GC 过程中程序运行出现了内存不足的情况，将会再启用Serial Old 垃圾收集器进行垃圾回收。导致停顿时间过长。**
* 还有就是标记--清理方法带来的内存碎片的问题，不过每次在发生一次FullGC 之后进行一次内存整理，这个问题可以通过CMSFullGCsBeforeCompaction 参数来解决，该参数表示执行过若干次收集之后，来一次整理的操作。

#### G1 收集器

* 从全局上来看是使用的**标记-整理** 算法实现，在两个region之间的看起来是使用，**复制-收集** 算法来实现的。
* G1 内存空间被划分为了多个大小相等的独立区域(Region), 虽然也分为年轻代和老年代，但是它们在物理空间上已经不是隔离的了。
* G1收集器可以单独完成整个堆空间的垃圾回收，根据每个region 的回收价值排序，优先回收价值最大的，不会产生内存碎片。

#### G1 收集器的运作过程

1. 初始标记（暂停）
2. 并发标记
3. 重新标记（这里的重新标记用的算法和CMS 不一致，CMS 采用的是增量更新，而G1采用的是原始快照算法）
4. 筛选回收（暂停，因为涉及到对象整理，会移动对象）

**Humongous区域**

* 专门用来存储大对象，G1认为只要大小超过Region容量一半就是大对象，对于超过了Region容量就称之为超级大对象，会直接存放在连续的**Humongous** 区域中。

**可预测的停顿时间**

* 之所以停顿时间可预测是因为，不再需要进行全域的堆内存回收，而只需要回收region 区域即可

* 更具体的处理思路是让G1收集器去跟踪各个Region里面的垃 圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默 认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来

* **如何处理跨region 引用问题**

  通过记忆集来解决，避免全堆作为CGReoots 进行扫描。（需要注意的是，G1的记忆集比CMS 的卡表实现更为复杂，卡表只记录了“谁指向我”，这种结构还记录了“我指向谁”），并且对于每个region 都需要记录这样一个卡表，而在CMS 中只需要记录老年代到新生代的引用即可。

**G1 的优点**

* 这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

**G1 的缺点**

* 维护卡表以及各个region 回收价值的预算，需要更多的内存资源占用

* 在小内存应用上CMS 算法表现更优异，而在大内存的应用上 G1算法表现更加优异

####　Shenandoah（低延迟垃圾收集器）

与G1不同点

* 支持并发回收整理算法
* 没有新老年代的分区region
* 不使用记忆卡来维护跨region 引用

#### ZGC

* ZGC收集器是一款基于Region内存布局的，（暂时） 不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低 延迟为首要目标的一款垃圾收集器。接下来，笔者将逐项来介绍ZGC的这些技术特点

### 对象标记错误问题

* 当且仅当以下两个条件同时满足时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色：
  1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
  2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。
* 并发扫描的话，可以参考**三色扫描标记法**来理解

### 堆上内存分配

#### 新生代分配

* 一般情况下是先分配在新生代的Eden 区域, 当然也存在特殊情况直接分配到老年代的情况。当Eden区域内存不足的时候便会触发一次MinorGc。
* 如果另外一块 Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直 接进入老年代，这对虚拟机来说就是安全的

#### 老年代分配

* 因为新生代的可以使用的区域是一个eden+Survivor (from) ，当发生minorGc 的时候，会将存活的对象移动至Survivor(to) 区域，如果survivor(to) 存放不下，则会通过分配担保机制进入老年代。

* 如果足够存放则GC 年龄加1，并且from 区域和to区域互换。

* 当然，对于大型对象或者长数组也是有可能直接分配至老年代内存上的。

* 而对于在新生代中长期存活的对象**也就是反复在 from 和 to 区域之间来回复制的对象** ，当GC 年龄超过15(默认值)次之后便可以进入老年代。

* 还有一种情况需要注意，就是当survivor 中**相同年龄的所有对象**的内存之后，大于survivor 总大小的一半之时也会提前进入老年代。


#### 内存担保

* 每次进行一次Minor Gc 之前都会检查当前老年代所剩余的空间是否大于当前新生代的全乎对象大小，如果大于的话那么说明这次Gc 是足够安全的。
* 如果不成立，则会查看是否允许担保失败，如果允许则进一步查看老年代的剩余空间是否大于历次从新生代移动至老年代对象大小的平均值，如果大于则尝试进行一次Minor GC。如果小于或者加入不允许担保失败，则需要触发一次FullGC。
* 再不济，在上述条件通过之后，最后进行分配还是失败了的话，依然会进行一次FullGc,这样也是最耗时的，因为连续来了两次 GC。

