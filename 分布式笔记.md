## 分布式笔记

### 分布式一致性协议

* 在一致性协调的框架中，一般会涉及到一个协调者，以及其他多个执行者。当一个事务被分成多个事务且分散在多个节点上执行时，如何保证事务的一致性？

#### 两段式提交

* **阶段一：**

  提交事务执行请求，协调者首先向各参与者发起执行事务的请求，然后等待个参与者的响应信息

  * 参与者开始执行，并且记录UNDO 日志，如果参与者执行ok 则向协调者发出 YES 的响应，如果执行失败则发送 NO
  * 协调者如果收到所有参与者都返回了OK ,或者 有一个返回NO 或者 等待任何一个参与者响应超时，则会直接进入第二阶段。

* **阶段二：**

  提交事务请求，协调者根据各个参与者的响应信息来决定是否提交事务，或者进行回滚，参与则提交或者回滚成功，则返回协调者 执行OK, 协调者判断该次事务结束。

* 缺点：

  * 容错性差，如果其中协调者挂了，则所有参与者都阻塞在等待提交的过程中而无法处理其他事务。
  * 会出现数据不一致的情况，如果在提交过程中，有一部分参与者提交失败，则此时便处于不一致的情况。

#### 三段式提交

* 相比于二阶段提交来说，三阶段提交是把 提交事务执行请求分为了两个阶段，即 事务执行询问+事务执行预提交。

* **阶段一**

  协调者会向各个参与者发起一个canCommit 的询问请求，参与者根据自身情况决定是返回的响应值。

* **阶段二**

  如果阶段一 所有参与者都返回 YES 响应的话，则会提交事务执行请求，如果有返回为 NO 或者等待超时的参与者则会直接执行事务中断请求。

  如果参与者无论收到了 abort 的中断请求，还是等待协调者出现超时的情况，自身都会执行中断事务的操作。如果参与者成功执行，则向协调者返回YES 响应。

* **阶段三**

  如果在执行阶段二之后，所有参与则都响应YES, 则执行事务提交。如果有响应超时或者返回NO 的参与者，则执行事务中断操作。

  当阶段三的doCommit 或者 abort 事件没有传达到 参与者，参与者依然会战哎等待超时之后继续执行提交事务。

* **优缺点**

  参与者自身具有等待超时的降级机制，不会出现长时间阻塞了。

  缺点就是，也可能造成数据不一致的情况。

#### Paxos 协议



### ZookeePer

#### 前提知识

* **Leader**:  是所有请求的唯一处理者，保障事务处理的顺序性 ，协调集群各机器的调度。
* **Follwer**：主要负责Leader 选举、处理客户端的非事务请求，将事务请求转发给leader 节点
* **Observer**：是独立于集群事务之外的一个观察者角色，不参与事务投票与选举投票，只能处理客户端的非事务性请求。
* leader 节点每次接收到客户端的事务请求之后，都会生成一个全局递增的事务ID ZXID，作为此次事务的一个标识。
* leader 会与每一个follower 维护一个队列，按照事务的先后顺序分发给follower节点。

### ZAB 协议的三阶段

* 发现阶段
* 数据同步阶段
* 消息广播阶段

#### Leader 选举

* zab 协议的 发现阶段也就是leader的选举阶段，简而言之就是在集群中选举一个事务ID 最大的节点，如果事务id 一致的话，则会更加SID 即服务id 来选举，SID大的即为leader。

* leader的选举有如下两种情况：

#### 服务启动选举

1. 发起投票

   * 比如集群中有两台服务器A和B，启动初期没有leader 两台服务器都处于Looking 的状态，开始投票，默认都会投**自身为leader 节点**。 
   * 每个投票的数据结构如下所示(ZXID,SID)

2. 投票检查

   * 检查投票是否来自于Looking的机器，以及是否属于本轮次的投票。

3. 投票处理

   * 在投票处理的第一步，会受限判断外部投票的选举轮次是否和当前一致，如果小于则直接抛弃不做任何处理，如果大于则需要将当前轮次更新，并且清空所有投票信息，再进行内部投票的PK, 最后再将新的内部投票发送出去。

   * 每台服务器在收到投票之后会 将选票中的事务ZXID 与自身投票的ZXID 做对比，如果比自身投票信息大，则会将其替代自身的选票信息，并且再向其他机器发送一次投票。
   * 如果选票中的ZXID 比自身的ZXID 小，则会忽略此次投票并且重新将原有选票再一次发送给其他机器 。

4. 处理投票

   * **每一次投票之后 服务器都会统计一下是否存在过半的机器 接收了相同的投票即 (n/2+1)**，这就意味着leader 选举投票完成。
   * 统计投票的关键就在于，统计当前是否存在过半机器认同了当前机器的内部投票，如果认同了则说明leader 已经选举成功。

5. 状态变更

   * 投票完成之后，各个服务器需要进行状态变更，leader 机器变更为Leading 状态，follower机器变更为following 状态。

#### 运行时选举

* 当Leader 节点出现故障，或者当前机器发现自身已经无法和leader 取得联系则会触发 运行时的Leader选举过程。
* 但是如果此时只有一台机器失去联系，当它试图进行投票的时候会被告知当前Leader节点的信息。它需要进行数据同步操作即可。
* 具体的选举过程和服务启动类似，只不过当开始触发leader选举的时候，各个节点都会将自身的状态置为Looking 状态。

#### 链接建立过程

* Zookeeper 服务端在进行数据同步，投票选举的过程中都需要进行通信链接，zk 为的规则是，只允许SID 大的服务器向SID 小的服务器发起链接请求否则将拒绝链接，然后主动向请求方发起链接请求。

#### 数据同步

##### 正常情况

* 新产生的Leader 节点需要将其自身的事务，同步给那些落后于Leader节点的follower节点。leader 会为每个follower 维护一个队列，将follower 未提交的事务的执行事务，以及提交事务 一齐发送过去。直到超过半数的节点于leader节点数据保持了一致。

##### 需要放弃事务的情况

* 当一个带有上一轮leader 暂未提交事务 的节点重新启动时，在于leader 节点数据同步的过程中，leader 节点会要求其放弃上一轮遗留下来的事务，也就是需要执行回退操作。

#### 消息广播机制

* 首先当 leader 接收到一个事务请求之后，在本机执行的同时会将该事务广播给其他follwer 节点，然后等待follower 节点的响应。
* leader 不需要等到所有的follower节点都返回，只需要超过一半的节点**包括leader节点本身** 返回，那么就会将提交的请求发送给所有的follower ，同时其自身也会将事务进行提交。

##### 事务处理细节

* Leader 收到客户端创建的一个事务型请求时，首先会在本地生成一个事务提案，将事务信息序列化生成一个Proposal对象，这个对象即代表一个提案。
* 随后Leader 会将该提案广播至所有的follower 服务器
* 事务广播完成之后，就开始收集事务投票信息，如果有一半以上的follower 同意该事务，则继续进行commit 阶段。
* 只要真正提交之后，事务的ZXID 才在follower 服务器上可见。

#### 崩溃恢复机制

**什么情况下进入崩溃恢复机制?**

* 当Leader 机器崩溃，或者集群中超过半数的机器与Leader 失去心跳链接，此时就需要通过崩溃恢复来达到整体的一致性。

**需要解决什么问题?**

* 消息崩溃机制主要需要解决如下两种问题：
* 情况一：当leader节点接收到客户端的请求，自身执行完成之后 然后leader节点出现崩溃，ZAB 协议需要保障重新选举出来的新的Leader 节点需要**丢弃该事务**。
* 情况二：当leader节点接收到客户端请求之后，并且事务执行已经成功广播给各个子节点，当需要执行事务A提交的时候，Leader节点挂了，这时候就需要确保，只要再Leader节点提交过的事务，也务必需要在其他节点进行提交。**也就是说只要 有一台机器成功提交了事务，那么其他节点也必须提交该事务**

**选举出新的Leader节点**

* zab 协议将会从所有的Follower节点中选举出一个 拥有 最大 ZXID 提交记录的节点，那么可以确保该Leader 拥有所有已经提交过的事务记录。（**问题时这个最大的ZXID 是指执行过的事务提案子的 ID ，可能还没提交过**）
* 选举出新的节点之后，剩余的事情就是进行follower节点和leader 节点之间的数据同步了。

