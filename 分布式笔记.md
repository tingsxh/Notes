[TOC]



## 分布式笔记

### 理论

#### CAP

* 一致性
* 可用性
* 分区容错性

#### BASE

* 基本可用
* 弱状态
* 最终一致性

### 分布式一致性协议

* 在一致性协调的框架中，一般会涉及到一个协调者，以及其他多个执行者。当一个事务被分成多个事务且分散在多个节点上执行时，如何保证事务的一致性？

#### 两段式提交

* 在关系型数据库中广泛用于分布式事务的协调

* **阶段一：**

  提交事务执行请求，协调者首先向各参与者发起执行事务的请求，然后等待个参与者的响应信息

  * 参与者开始执行，并且记录UNDO、REDO 日志，如果参与者执行ok 则向协调者发出 YES 的响应，如果执行失败则发送 NO
  * 协调者如果收到所有参与者都返回了OK ,或者 有一个返回NO 或者 等待其中任何一个参与者响应超时，则会直接进入第二阶段。

* **阶段二：**

  提交事务请求，协调者根据各个参与者的响应信息来决定是否提交事务，或者进行回滚，参与者提交或者回滚成功，则返回协调者 执行OK, 协调者判断该次事务结束。

* **提交**：当所有参与者都返回阶段一执行成功，那么协调者将发起提交事务的请求，当协调者收到所有参与者的ack响应之后，事务完成。

* **中断**：当收到参与者返回的NO 响应或者等待参与者响应超时之后，协调者会发起回滚的操作，当协调者收到所有参与者返回ack响应之后，事务完成。

* 优点：

  简单，方便。

* 缺点：

  * 阻塞问题：在阶段一执行完成，等待阶段二提交的过程中，所有的执行者都会处于等待其他参与者响应的状态。

  * 容错性差：如果其中协调者挂了，则所有参与者都阻塞在等待提交的过程中而无法处理其他事务。
  * 如果协调者挂了，commit 请求只发送了一半，那么会出现数据不一致的情况，如果在提交过程中，有一部分参与者提交失败，则此时便处于不一致的情况。

#### 三段式提交

* 相比于二阶段提交来说，三阶段提交是把 **提交事务执行请求**分为了两个阶段，即 事务执行询问+事务执行预提交。

* **阶段一**

  协调者会向各个参与者发起一个canCommit 的询问请求，参与者根据自身情况决定是返回的响应值。

* **阶段二**

  如果阶段一 所有参与者都返回 YES 响应的话，则会提交事务执行请求，如果有返回为 NO 或者等待超时的参与者则会直接执行事务中断请求。

  如果参与者无论收到了 abort 的中断请求，还是等待协调者出现超时的情况，自身都会执行中断事务的操作。如果参与者成功执行，则向协调者返回YES 响应。

  **阶段三**

  如果在执行阶段二之后，所有参与则都响应YES, 则执行事务提交。如果有响应超时或者返回NO 的参与者，则执行事务中断操作。

  当阶段三的doCommit 或者 abort 事件没有传达到 参与者，**参与者依然会战哎等待超时之后继续执行提交事务。**

* **优缺点**

  **参与者自身具有等待超时的降级机制，不会出现长时间阻塞了。**

  缺点就是，也可能造成数据不一致的情况，因为当需要回滚的时候协调者挂了，那么其余的参与者还是会自动提交。

#### Paxos 协议

* proposer

* accepter

* learner

* 第一阶段

  存在多个提议者和接受者，那么接受者接受谁的意见，谁是主要提议者，接受者就主要处理这个提议者的提议了。

* 第二阶段

  由上阶段选举出来的意见领袖提出提议，如果多数接受者接受意见，那么提议就通过了。

* **核心问题**

  1. 接受者听谁的，也就是怎么选择意见领袖？

     每个意见提议者都会有一个编码，接受者只听从编码最大者的意见提议。

  2. 提议的通过流程

     每个意见提议者向所有的接受者广播自己的提议，接受者会判断，如果之前你是上一个阶段被确定的提议者，那么我就通过你，如果接受者之前已经通过了一个提议，那么这个时候不管你的编码大小如何，都需要将自己的提议改成这个提议（**为了让整体快速趋于一致**）。但是如果这个时候接受者还没有通过任何提议的话，并且这个时候你的编号比接受者当前记录的要大，那么接受者会会将你记录为意见领袖。

* 以上就是paxos 的核心理论。详见知乎解释(https://www.zhihu.com/question/19787937)

### ZookeePer

#### 前提知识

* **Leader**:  是所有请求的唯一处理者，保障事务处理的顺序性 ，协调集群各机器的调度。
* **Follwer**：主要负责Leader 选举、处理客户端的非事务请求，将事务请求转发给leader 节点
* **Observer**：是独立于集群事务之外的一个观察者角色，不参与事务投票与选举投票，只能处理客户端的非事务性请求。
* leader 节点每次接收到客户端的事务请求之后，都会生成一个全局递增的事务ID ZXID，作为此次事务的一个标识。
* leader 会与每一个follower 维护一个队列，按照事务的先后顺序分发给follower节点。

#### 顺序一致性

* 从同一客户端发起的事务请求，最终会严格的按照发起的顺序被应用到zookeeper中去

#### 原子性

* 所有的事务请求的处理结果，在整个集群中的应用情况是原子的，要么都提交，要么都回滚。

#### 可靠性

* 

#### 实时性

* zookeeper 只保证最终一致性

#### 知识点

* zookeeper 采用类似文件系统的数据结构，全量的数据存储在内存当中以提高吞吐。
* 每个客户端的更新请求都会被分配一个全局唯一递增的编号，编号的顺序反映了事务执行的先后顺序

#### zk的商业应用

* 分布式锁，master 选举，节点监控，任务分发

#### 数据结构

* Znode 节点分为持久化节点和临时节点，通过添加SEQUENTIAL 属性，节点被创建的时候会自动在节点名后面添加一个整形数字

#### 与Paxos 差异

* 都存在一个leader 进程的角色，由其负责协调多个Follower进程的运行。
* zab 协议多了一个数据同步阶段。

**ZAB 协议核心**

**所有事务必须由一个全局唯一的服务器来处理，并且按照顺序处理，这个服务器称之为leader，leader 负责将一个客户端端事务请求转换为一个事务提议，并且将该提议广播给集群中所有的follower服务器，之后等过半的follower服务器都反馈执行完毕之后，再向所有的服务器发送commit 消息。**

#### 崩溃恢复机制

**什么情况下进入崩溃恢复机制?**

* **当Leader 机器崩溃，或者集群中超过半数的机器与Leader 失去心跳链接，此时就需要通过崩溃恢复来达到整体的一致性**。
* 当整个集群刚启动的时候需要选举出一个新的leader节点

**需要解决什么问题?**

* 消息崩溃机制主要需要解决如下两种问题：
* 情况一：当leader节点接收到客户端的请求，自身执行完成之后 然后leader节点出现崩溃，ZAB 协议需要保障重新选举出来的新的Leader 节点需要**丢弃该事务**。
* 情况二：当leader节点接收到客户端请求之后，并且事务执行已经成功广播给各个子节点，当需要执行事务A提交的时候，Leader节点挂了，这时候就需要确保，只要再Leader节点提交过的事务，也务必需要在其他节点进行提交。**也就是说只要 有一台机器成功提交了事务，那么其他节点也必须提交该事务**

### ZAB 协议三阶段

* 发现Leader
* 将follower数据与leader保持同步
* 消息广播阶段

#### Leader 选举

* leader的选举有如下两种情况：

##### 服务启动选举

1. 发起投票

   * 比如集群中有两台服务器A和B，启动初期没有leader 两台服务器都处于Looking 的状态，开始投票，默认都会投**自身为leader 节点**。 
   * 每个投票的数据结构如下所示(ZXID,SID)

2. 投票检查

   * 检查投票是否来自于Looking的机器，以及是否属于本轮次的投票。

3. 投票处理

   * 在投票处理的第一步，会首先判断外部投票的选举轮次是否和当前一致，如果小于则直接抛弃不做任何处理，如果大于则需要将当前轮次更新，并且清空所有投票信息，再进行内部投票的PK, 最后再将新的内部投票发送出去。

   * 每台服务器在收到投票之后会 **将选票中的事务ZXID 与自身投票的ZXID 做对比，如果比自身投票信息大，则会将其替代自身的选票信息**，并且再向其他机器发送一次投票。
   * 如果选票中的ZXID 比自身的ZXID 小，则会忽略此次投票并且重新将原有选票再一次发送给其他机器 。

4. 统计投票

   * **每一次投票之后 服务器都会统计一下是否存在过半的机器 接收了相同的投票即 (n/2+1)**，这就意味着leader 选举投票完成。
   * 统计投票的关键就在于，统计当前是否存在过半机器认同了当前机器的内部投票，如果认同了则说明leader 已经选举成功。

5. 服务器状态变更

   * 投票完成之后，各个服务器需要进行状态变更，leader 机器变更为Leading 状态，follower机器变更为following 状态。

##### 服务运行时选举

* 当Leader 节点出现故障，或者当前机器发现自身已经无法和leader 取得联系则会触发 运行时的Leader选举过程。
* 但是如果此时只有一台机器失去联系，当它试图进行投票的时候会被告知当前Leader节点的信息。它需要进行数据同步操作即可。
* 具体的选举过程和服务启动类似，只不过当开始触发leader选举的时候，各个节点都会将自身的状态置为Looking 状态。

1. 状态变更
   * 当leader 挂了之后，余下的非Observer 服务器都会将自己的服务器状态变更为LOOKING，然后进入选举流程

#### leader 选举算法分析

* 三种选举算法`leaderElection`,`FastLeaderElection`(TCP版和UDP 版本)
* 进入LOOKING 选举，第一次投票都投自己，然后根据ZXID 和sid 做投票变更，最后确定leader

**选举出新的Leader节点**

* zab 协议将会从所有的Follower节点中选举出一个 拥有 最大 ZXID 提交记录的节点，那么可以确保该Leader 拥有所有已经提交过的事务记录。（**问题是这个最大的ZXID 是指执行过的事务提案子的 ID ，可能还没提交过**）
* 选举出新的节点之后，剩余的事情就是进行follower节点和leader 节点之间的数据同步了。

##### 消息队列

* 每个节点和其他节点之间都建立一个独立的通信队列，根据每台服务器的SID 分别建立sendWorker和RecvWorker。
* 每个RecvWorker 不断的从相应的TCP 连接中读取消息，并将其保存到recvQueue队列中。
* 每个SendWorker 不断的从消息发送队列取出消息，还会保存一个lastSendMessage,就是最近发送的一个消息。

##### 主从链接建立过程

* Zookeeper 服务端在进行数据同步，投票选举的过程中都需要进行通信链接，zk 为的规则是，只允许SID 大的服务器向SID 小的服务器发起链接请求否则将拒绝链接，然后主动向请求方发起链接请求。

##### 核心步骤

1. 自增选举轮次
2. 初始化选票，格式为(sid,zxid)
3. 发送初始化选票
4. 接收外部投票
5. 判断投票轮次（如果接收到的外部选票轮次小于自身轮次则忽略该投票，如果轮次大于自身的投票轮次那么更新自身的选举轮次，清空当前收到的所有投票，然后使用初始化的投票进行PK。如果轮次相等的话直接进入投票PK）
6. 投票PK(1.如果外部选票的选举轮次大于自身的话，2.外部投票的ZXID 大于自身的话，3.如果外部的SID 大于自身的话)
7. 投票变更
8. 投票归档

#### 数据同步

##### 正常情况

* 新产生的Leader 节点需要将其自身的事务，同步给那些落后于Leader节点的follower节点。leader 会为每个follower 维护一个队列，将follower 未提交的事务的执行事务，以及提交事务 一齐发送过去。直到超过半数的节点与leader节点数据保持了一致。

##### 需要放弃事务的情况

* 当一个带有上一轮leader 暂未提交事务 的节点重新启动时，在与leader 节点数据同步的过程中，leader 节点会要求其放弃上一轮遗留下来的事务，也就是需要执行回退操作。

##### 事务处理细节

* Leader 收到客户端创建的一个事务型请求时，首先会在本地生成一个事务提案，将事务信息序列化生成一个Proposal对象，这个对象即代表一个提案。
* 随后Leader 会将该提案广播至所有的follower 服务器
* 事务广播完成之后，就开始收集事务投票信息，如果有一半以上的follower 同意该事务，则继续进行commit 阶段。
* 只要真正提交之后，事务的ZXID 才在follower 服务器上可见。

#### 消息广播机制

* 首先当 leader 接收到一个事务请求之后，在本机执行的同时会将该事务广播给其他follwer 节点，然后等待follower 节点的响应，队列中是按照事务的ZXID 顺序排序的，所以能保证顺序一致性。
* leader 不需要等到所有的follower节点都返回，只需要超过一半的节点**包括leader节点本身** 返回，那么就会将提交的请求发送给所有的follower ，同时其自身也会将事务进行提交。
