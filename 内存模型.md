* 编译器重排序，处理器重排序

### 重排序问题

* 由于现在所有的处理器都会支持写缓冲，所以会导致处理器的内存操作顺序与实际内存操作顺序不一致。JMM 是通过在指令序列中插入内存屏障来禁止特地类型的处理器重排序的。
* 四种内存屏障分别是 `LoadLoad`,`StoreStore`,`LoadStore`,`StoreLoad`
* StoreStore 禁止上面的普调写和下面的volatile 写重排序，StoreLoad 屏障禁止上面的volatile写与下面的volatile读重排序
* LoadLoad 禁止下面的普通读与上面的volatile读重排序， LoadStore 禁止下面所有的普通写与上面的volatile 读重排序

#### happens-before 关系

* 两个操作直接具有happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在第二个操作之前。




#### 数据依赖性

* 三种不允许重排序的数据依赖性关系
* 1. 写后读(写一个变量再读一个变量)、2.写后写(写一个变量再写一个变量)、3.读后写(读一个变量再写一个变量)
* 以上三种重排序任意一种都会改变程序的运行结果，JMM 为了保证 as-if-serial 语义，会禁止此类的重排序操作。
* 在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

#### 顺序一致性模型

* 在JMM中如果多线程没有做同步控制，那么由于存在虚拟的工作内存模型，所以当前线程看到的内存操作顺序可能与其他线程看到的内存操作顺序是不一致的。
* 与JMM内存模型的差异
顺序一致性模型保证单线程内的操作会按照程序的顺序执行，而JMM 不保证单线程内的操作会按程序的顺序执行
顺序一致性模型保证所有线程只能懒得一致的操作执行顺序
JMM 不保证对64位的long型和double 型变量写操作具有原子性

#### volatile 内存语义
* 可见性，对一个volatile 变量的读总是能看到该变量最新被写入的值
* 原子性，对单个volatile变量的读写具有原子性
* 线程A 写一个volatile 变量，线程B读一个volatile 变量实际上就是线程A 向线程B 发送消息的一个过程。

#### volatile 内存屏障

* 在每个volatile 写操作的前面插入一个StoreStore 屏障
* 在每个写操作后面插入一个StoreLoad 屏障
* 在每个volatile 读操作后面插入一个LoadLoad 屏障
* 在每个volatile读操作的后面插入一个LoadStore 屏障
