* 编译器重排序，处理器重排序

### 重排序问题

* 由于现在所有的处理器都会支持写缓冲，所以会导致处理器的内存操作顺序与实际内存操作顺序不一致。JMM 是通过在指令序列中插入内存屏障来禁止特地类型的处理器重排序的。
* 四种内存屏障分别是 `LoadLoad`,`StoreStore`,`LoadStore`,`StoreLoad`
* StoreStore 禁止上面的普调写和下面的volatile 写重排序，StoreLoad 屏障禁止上面的volatile写与下面的volatile读重排序
* LoadLoad 禁止下面的普通读与上面的volatile读重排序， LoadStore 禁止下面所有的普通写与上面的volatile 读重排序

#### happens-before 关系

* 两个操作直接具有happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行，happens-before仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在第二个操作之前。
* 锁规则：锁的释放先于锁的获取
* volatile 变量的写入先于volatile 变量的读取
* 传递性
* 程序规则，一个线程的每个操作先于该线程中任意的后续操作




#### 数据依赖性

* 三种不允许重排序的数据依赖性关系
* 1. 写后读(写一个变量再读一个变量)、2.写后写(写一个变量再写一个变量)、3.读后写(读一个变量再写一个变量)
* 以上三种重排序任意一种都会改变程序的运行结果，JMM 为了保证 as-if-serial 语义，会禁止此类的重排序操作。
* 在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

#### 顺序一致性模型

* 在JMM中如果多线程没有做同步控制，那么由于存在虚拟的工作内存模型，所以当前线程看到的内存操作顺序可能与其他线程看到的内存操作顺序是不一致的。
* 与JMM内存模型的差异
顺序一致性模型保证单线程内的操作会按照程序的顺序执行，而JMM 不保证单线程内的操作会按程序的顺序执行
顺序一致性模型保证所有线程只能懒得一致的操作执行顺序
JMM 不保证对64位的long型和double 型变量写操作具有原子性

**两者模型差异**

1. JMM 不保证单线程内所有操作顺序执行
2. JMM 不保证所有线程都能看到一致的执行顺序

#### volatile 内存语义
* 可见性，对一个volatile 变量的读总是能看到该变量最新被写入的值
* 原子性，对单个volatile变量的读写具有原子性
* 线程A 写一个volatile 变量，线程B读一个volatile 变量实际上就是线程A 向线程B 发送消息的一个过程。

#### volatile 内存屏障

* 在每个volatile 写操作的前面插入一个StoreStore 屏障
* 在每个写操作后面插入一个StoreLoad 屏障
* 在每个volatile 读操作后面插入一个LoadLoad 屏障
* 在每个volatile读操作的后面插入一个LoadStore 屏障


#### 锁的内存语义

* 锁的释放--获取是具有相应的happens-before 关系的
* 锁的释放会将线程本地内存中的共享变量刷新到主内存当中，与此相同的是线程获取锁时，也会将本地内存中的共享变量置为失效，从而使得同步代码块中的变量读取必须从主内存中读取。
* CAS 具有volatile 变量的读-写内存语义

#### final 域的内存语义

* 写final域的重排序规则要求，在对象引用被任意线程可见之前，对象的final 域属性一定已经被初始化过了，而普通域不具有这个保障。
* 读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该 域还没有被写线程A写入，这是一个错误的读取操作。
* 而读final域的重排序规则会把读对象 final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作
* 因为final 的语义就是不可变的，为了强化这一规则，才有的final 内存语义。
* 在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如， 一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个 线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子 就是在旧的Java内存模型中，String的值可能会改变。


* as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同
步的多线程程序的执行结果不被改变。

#### JMM内存模型可见性保障

1. 单线程程序，不会出现内存可见性问题，程序的执行结果与改程序在顺序一致性模型中的执行结果相同。
2. 正确同步的多线程中，正确同步的多线程程序的执行将具有顺序一致性（与顺序一致性模型一致）



